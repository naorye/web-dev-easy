<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CSS | Web Development is Easy!]]></title>
  <link href="http://webdeveasy.com/categories/css/atom.xml" rel="self"/>
  <link href="http://webdeveasy.com/"/>
  <updated>2014-01-02T21:22:53+02:00</updated>
  <id>http://webdeveasy.com/</id>
  <author>
    <name><![CDATA[NaorYe]]></name>
    <email><![CDATA[mailto:naorye@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Complete Grunt Build Script for Single Page Application]]></title>
    <link href="http://webdeveasy.com/writing-complete-build-script-with-grunt/"/>
    <updated>2013-11-23T20:51:33+02:00</updated>
    <id>http://webdeveasy.com/writing-complete-build-script-with-grunt</id>
    <content type="html"><![CDATA[<p><a href="#" target="_blank">Grunt</a> is a great tool for creating a build script for your web application. It can easily save you tons of time by creating automation to your build process from development to production. For the last few days I've created a build script for a project I am doing using Grunt and I would like to share it. My build handles many things, for example:</p>

<ul>
    <li>Compiles SASS to CSS</li>
    <li>Concatenates and minifies your CSS and JavaScript files</li>
    <li>Adds needed browser prefixes for CSS styles (automagically!)</li>
    <li>Runs development and production server</li>
    <li>Creates a production version out of your development code</li>
</ul>


<p>In this article I will explain how to create such a build script. After reading this article, it will also be easy for you to add other tasks according to your build needs.</p>

<!-- more -->


<p><em>Installing Grunt tasks:</em> During this article we will use several Grunt tasks. Near each task we use, I added a link to it's git repository and a command to run in order to install it.</p>

<h2>Preparation</h2>

<p>Before we start we need to create our working environment. Follow those simple steps:</p>

<h3>Initializing Node and Grunt</h3>

<p>If you haven't done so, install <a href="http://nodejs.org" target="_blank">Node.js</a> (npm will be installed with node) and Grunt command line interface (<code>npm install -g grunt-cli</code>). Installing Grunt CLI is not installing the Grunt task runner, but it will put the grunt command in your system path, allowing it to be run from any directory. <br/>
Go to your project folder and create a package.json file by typing <code>npm init</code> and filling the tutorial. Eventually you'll get a file similar to this:
```javascript package.json
{</p>

<pre><code>{
    "name": "complete-grunt-build-script-for-single-page-application",
    "version": "0.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
},
"author": "",
"license": "BSD"
</code></pre>

<p>}
<code>
Now it is time to install the Grunt task runner. Typing `npm install grunt --save-dev` will install the Grunt task runner and will add it to package.json as a dev dependency.   
Now create a Gruntfile.js file. In this file we will define and configure our build tasks. Create the following Gruntfile.js file near package.json:
</code>javascript Gruntfile.js
module.exports = function(grunt) {</p>

<pre><code>grunt.initConfig({

});
</code></pre>

<p>};
```</p>

<h3>Grunt Tasks Loader</h3>

<p>Our build script is going to use many Grunt tasks. Each task should be loaded by calling <code>grunt.loadNpmTasks(...);</code> command. In order to save all those calls and prevent situations where we forget to load tasks, I like to use the <a href="https://github.com/sindresorhus/load-grunt-tasks" target="_blank">load-grunt-tasks</a> plugin which loads Grunt tasks automatically (according to globbing patterns). In order to use this plugin, install it (<code>npm install load-grunt-tasks --save-dev</code>) and initialize it in Gruntfile.js:
```javascript Init load-grunt-tasks
module.exports = function(grunt) {</p>

<pre><code>require('load-grunt-tasks')(grunt);

grunt.initConfig({

});
</code></pre>

<p>};
```</p>

<h3>Define Working Folders</h3>

<p>In this build file We will use 3 different working folders:</p>

<ol>
    <li>`app` folder - where our source resides</li>
    <li>`.tmp` folder - a place to put all our temporary calculations</li>
    <li>`dist` folder - for our final distribution code (the "compiled" output)</li>
</ol>


<p>Let's create those three folders. <br/>
A wise thing to do is to define those working folders using <a href="http://chrisawren.com/posts/Advanced-Grunt-tooling#Using-variables-in-your-configuration" target="_blank">Grunt variables</a>. This will allow us to maintain our environment directory easily:
```javascript Define paths
grunt.initConfig({</p>

<pre><code>// configurable paths
paths: {
    app: 'app',
    temp: '.tmp',
    dist: 'dist'
}
</code></pre>

<p>});
```
Accessing those variables in tasks is made by underscore templates ('&lt;%= ... %>'), for example: '&lt;%= paths.app %>'.</p>

<h2>Development Server</h2>

<p>Our first mission is to create a task that will execute our source in a development server. This task has to inject development configuration, compile SASS to CSS, add browser prefixes to this CSS and open the application in a browser.</p>

<h3>Clean Working Folders</h3>

<p>First thing to do is to clean the folders that we will use in this process. This is done by the <a href="https://github.com/gruntjs/grunt-contrib-clean" target ="_blank">grunt-contrib-clean task</a> (npm install grunt-contrib-clean --save-dev). This task get the folders to be cleaned. This is how we configure it:
```javascript Cleaning working folder
grunt.initConfig({</p>

<pre><code>...
...
clean: {
    /* Delete all files from .tmp */
    server: '&lt;%= paths.temp %&gt;'
},
...
...
</code></pre>

<p>});
<code>``
Whenever we will run 'clean:server', .tmp folder will be cleaned. As you can see, we used here the</code>paths.temp` variable that was defined before.</p>

<p>grunt.task.run([</p>

<pre><code>'clean:temp',
'templates:development',
'compass',
'copy:styles'
'autoprefixer',
'configureRewriteRules',
'connect:server',
'watch'
</code></pre>

<p>]);</p>

<h2>Defining a model for controller</h2>

<p>Let's start with a simple example. I would like to display a book view. This is the controller:
```javascript BookController
app.controller('BookController', ['$scope', function($scope) {</p>

<pre><code>$scope.book = {
    id: 1,
    name: 'Harry Potter',
    author: 'J. K. Rowling',
    stores: [
        { id: 1, name: 'Barnes &amp; Noble', quantity: 3},
        { id: 2, name: 'Waterstones', quantity: 2},
        { id: 3, name: 'Book Depository', quantity: 5}
    ]
};
</code></pre>

<p>}]);
<code>
This controller creates a model of book which can be later used in our template:
</code>html template for displaying a book</p>

<div ng-controller="BookController">
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
</div>


<p><code>
In case we would like to get the book data from a backend api, we can also use $http:
</code>javascript BookController with $http
app.controller('BookController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>var bookId = 1;

$http.get('ourserver/books/' + bookId).success(function(bookData) {
    $scope.book = bookData;
});
</code></pre>

<p>}]);
<code>
Notice that bookData is still a JSON object.
Later on we would like to do something with this data. For example, update the book, delete it or even do other operations that are not dealing with the backend, like generate a book image url according to requested size or determining whether the book is available. Those methods can be declared on our controller:
</code>javascript BookController with several book actions
app.controller('BookController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>var bookId = 1;

$http.get('ourserver/books/' + bookId).success(function(bookData) {
    $scope.book = bookData;
});

$scope.deleteBook = function() {
    $http.delete('ourserver/books/' + bookId);
};

$scope.updateBook = function() {
    $http.put('ourserver/books/' + bookId, $scope.book);
};

$scope.getBookImageUrl = function(width, height) {
    return 'our/image/service/' + bookId + '/width/height';
};

$scope.isAvailable = function() {
    if (!$scope.book.stores || $scope.book.stores.length === 0) {
        return false;
    }
    return $scope.book.stores.some(function(store) {
        return store.quantity &gt; 0;
    });
};
</code></pre>

<p>}]);
<code>
And later in our template:
</code>html template for displaying a complete book</p>

<div ng-controller="BookController">
    <div ng-style="{ backgroundImage: 'url(' + getBookImageUrl(100, 100) + ')' }"></div>
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
    <br/>
    Is Available: <span ng-bind="isAvailable() ? 'Yes' : 'No' "></span>
    <br/>
    <button ng-click="deleteBook()">Delete</button>
    <br/>
    <button ng-click="updateBook()">Update</button>
</div>


<p>```</p>

<h2>Sharing a model between controllers</h2>

<p>As long as the book's structure and methods are relevant only to one controller, all is fine and our work here is done. But as the application grows, there might be other controllers that will deal with books. Those controllers will sometimes need to fetch a book, update it, delete it or get it's image url or availability. Therefore we have to share the behaviors of a book between controllers. In order to do this we will use a factory that returns the book's behavior. Before writing this factory, I would like to mention here that we could make the factory return an object that contains helper methods for book (i.e. functions that get a book JSON and do what asked), but I prefer to use <a>prototype</a> for constructing a Book class, which I believe is the right choice:
```javascript Book model service
app.factory('Book', ['$http', function($http) {</p>

<pre><code>function Book(bookData) {
    if (bookData) {
        this.setData(bookData):
    }
    // Some other initializations related to book
};
Book.prototype = {
    setData: function(bookData) {
        angular.extend(this, bookData);
    },
    load: function(id) {
        var scope = this;
        $http.get('ourserver/books/' + bookId).success(function(bookData) {
            scope.setData(bookData);
        });
    },
    delete: function() {
        $http.delete('ourserver/books/' + bookId);
    },
    update: function() {
        $http.put('ourserver/books/' + bookId, this);
    },
    getImageUrl: function(width, height) {
        return 'our/image/service/' + this.book.id + '/width/height';
    },
    isAvailable: function() {
        if (!this.book.stores || this.book.stores.length === 0) {
            return false;
        }
        return this.book.stores.some(function(store) {
            return store.quantity &gt; 0;
        });
    }
};
return Book;
</code></pre>

<p>}]);
<code>
This way all book's behavior is encapsulated in Book service. Now, let's use our shiny Book service in our BookController:
</code>javascript BookController that uses Book model
app.controller('BookController', ['$scope', 'Book', function($scope, Book) {</p>

<pre><code>$scope.book = new Book();
$scope.book.load(1);
</code></pre>

<p>}]);
<code>
As you can see, the controller became very thin. It now creates a Book instance, assigns it to the scope and loads it from the backend. When the book will be loaded, it's properties will be changed and so the template. Keep in mind that other controllers that interact with a book, simply inject the Book service. We have to change the template to use book's methods as well:
</code>html template that uses book instance</p>

<div ng-controller="BookController">
    <div ng-style="{ backgroundImage: 'url(' + book.getImageUrl(100, 100) + ')' }"></div>
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
    <br/>
    Is Available: <span ng-bind="book.isAvailable() ? 'Yes' : 'No' "></span>
    <br/>
    <button ng-click="book.delete()">Delete</button>
    <br/>
    <button ng-click="book.update()">Update</button>
</div>


<p>```
Up to here we saw how to model a data, encapsulate all its methods in one class and share this class between controllers without code duplication.</p>

<h2>Model of the same book in several controllers</h2>

<p>So we have a book model definition and several controllers that work with books. After using this modeling architecture you will notice that there is a big problem.
Up to now we supported several controllers that do operations with books. But what will happen if two controllers will deal with the same book? <br/>
Assume that we have a section with a list of names of all our books and another section with an editable view of a book. We have two controllers, one for each section. The first controller loads the books list and the second controller loads a single book. Our user sees the second section, edit the name of the book and then presses on the "update" button. The update process will succeed and the book name will be changed. But in the books list section the user still sees the old name! What happened actually is that there were two different instances of the same book - one for the books list and one for the editable view. When the user edited the book's name, he actually changed the name property of the book instance that was binded to the editable view. Whereas the book instance that was binded to the books list view didn't changed. <br/>
The solution for this problem is to share the same books instances with any controller that needs them. This way both the books list controller and the editable view controller will hold the same book instance and whenever this instance is changed, the changes will be reflected in all the views. Translating words to actions, we have to create a booksManager service (the letter b is not capital because it is an object and not a Class) that will manage books instances pool and will be responsible for returning instances of books. If the required instance doesn't exist in the pool, the service will create it. If the required instance already exists in the pool, the service will only return it. Keep in mind that all the functions that load instances of books will be defined eventually only in our booksManager service since it has to be the only component that provide books instances.
```javascript booksManager service
app.factory('booksManager', ['$http', '$q', 'Book', function($http, $q, Book) {</p>

<pre><code>var booksManager = {
    _pool: {},
    _retrieveInstance: function(bookId, bookData) {
        var instance = this._pool[bookId];

        if (instance) {
            instance.setData(bookData);
        } else {
            instance = new Book(bookData);
            this._pool[bookId] = instance;
        }

        return instance;
    },
    _search: function(bookId) {
        return this._pool[bookId];
    },
    _load: function(bookId, deferred) {
        var scope = this;

        $http.get('ourserver/books/' + bookId)
            .success(function(bookData) {
                var book = scope._retrieveInstance(bookData.id, bookData);
                deferred.resolve(book);
            })
            .error(function() {
                deferred.reject();
            });
    },
    /* Public Methods */
    /* Use this function in order to get a book instance by it's id */
    getBook: function(bookId) {
        var deferred = $q.defer();
        var book = this._search(bookId);
        if (book) {
            deferred.resolve(book);
        } else {
            this._load(bookId, deferred);
        }
        return deferred.promise;
    },
    /* Use this function in order to get instances of all the books */
    loadAllBooks: function() {
        var deferred = $q.defer();
        var scope = this;
        $http.get('ourserver/books)
            .success(function(booksArray) {
                var books = [];
                booksArray.forEach(function(bookData) {
                    var book = scope._retrieveInstance(bookData.id, bookData);
                    books.push(book);
                });

                deferred.resolve(books);
            })
            .error(function() {
                deferred.reject();
            });
        return deferred.promise;
    },
    /*  This function is useful when we got somehow the book data and we wish to store it or update the pool and get a book instance in return */
    setBook: function(bookData) {
        var scope = this;
        var book = this._search(bookData.id);
        if (book) {
            book.setData(bookData);
        } else {
            book = scope._retrieveInstance(bookData);
        }
        return book;
    },

};
return booksManager;
</code></pre>

<p>}]);
<code>
Our Book service is now without the load method:
</code>javascript Book model without the load method
app.factory('Book', ['$http', function($http) {</p>

<pre><code>function Book(bookData) {
    if (bookData) {
        this.setData(bookData):
    }
    // Some other initializations related to book
};
Book.prototype = {
    setData: function(bookData) {
        angular.extend(this, bookData);
    },
    delete: function() {
        $http.delete('ourserver/books/' + bookId);
    },
    update: function() {
        $http.put('ourserver/books/' + bookId, this);
    },
    getImageUrl: function(width, height) {
        return 'our/image/service/' + this.book.id + '/width/height';
    },
    isAvailable: function() {
        if (!this.book.stores || this.book.stores.length === 0) {
            return false;
        }
        return this.book.stores.some(function(store) {
            return store.quantity &gt; 0;
        });
    }
};
return Book;
</code></pre>

<p>}]);
<code>
Our EditableBookController and BooksListController controllers looks like:
</code>javascript EditableBookController and BooksListController that uses booksManager
app</p>

<pre><code>.controller('EditableBookController', ['$scope', 'booksManager', function($scope, booksManager) {
    booksManager.getBook(1).then(function(book) {
        $scope.book = book
    });
}])
.controller('BooksListController', ['$scope', 'booksManager', function($scope, booksManager) {
    booksManager.loadAllBooks().then(function(books) {
        $scope.books = books
    });
}]);
</code></pre>

<p>```
Notice that the templates remain the same as they still use instances. Now the application will hold only one book instance with id equals to 1 and any change on it will be reflected on all views that use it.</p>

<h2>Summary</h2>

<p>On this article I suggested an architecture for modeling data in AngularJS. First, I presented the default model binding of AngularJS, then I showed how to encapsulate the model's methods and operations so we can share it between different controllers, and finally I explained how to manage our models instances so all the changes will be reflected on all the application views.</p>

<p>I hope this article gave you ideas how to implement your data models. If you have any question, don't hesitate to ask!</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flexbox Accordion]]></title>
    <link href="http://webdeveasy.com/flexbox-accordion/"/>
    <updated>2013-10-26T15:45:02+02:00</updated>
    <id>http://webdeveasy.com/flexbox-accordion</id>
    <content type="html"><![CDATA[<p>I have made a css accordion using flexbox and I like to share it. This is how it looks like:</p>

<div class="flexbox-accordion-container">
    <ul class="actions-list">
        <li class="action-item facebook">
            Facebook
        </li>
        <li class="action-item google">
            GooglePlus
        </li>
        <li class="action-item linkedin">
            LinkedIn
        </li>
        <li class="action-item picasa">
            Picasa
        </li>
        <li class="action-item twitter">
            Twitter
        </li>
        <li class="action-item wikipedia">
            Wikipedia
        </li>
    </ul>
</div>


<!-- more -->


<br/>


<p>The markup and the css are pretty simple. We have a list of items, where the list is flexbox container and each item is a flex element. After defining this, all left to do is to define sizes, colors and the styling of each item. <br/>
Here is the code:
```html Flexbox accordion markup</p>

<ul class="actions-list">
    <li class="action-item facebook">
        Facebook
    </li>
    <li class="action-item google">
        GooglePlus
    </li>
    <li class="action-item linkedin">
        LinkedIn
    </li>
    <li class="action-item picasa">
        Picasa
    </li>
    <li class="action-item twitter">
        Twitter
    </li>
    <li class="action-item wikipedia">
        Wikipedia
    </li>
</ul>


<p><code>
</code>css Flexbox accordion css
/<em> Flex box define </em>/
.actions-list {</p>

<pre><code>display: -webkit-box;
display: -webkit-inline-flex;
display: -moz-inline-flex;
display: -ms-inline-flexbox;
display: inline-flex;  
</code></pre>

<p>}</p>

<p>.actions-list .action-item {</p>

<pre><code>-webkit-box-flex: 1;
-webkit-flex: 1 1 auto;
-moz-flex: 1 1 auto;
-ms-flex: 1 1 auto;
flex: 1 1 auto;

-webkit-transition: all 300ms ease;
-moz-transition: all 300ms ease;
-o-transition: all 300ms ease;
transition: all 300ms ease;

-webkit-box-sizing: border-box;
-moz-box-sizing: border-box;
box-sizing: border-box;

overflow: hidden;
</code></pre>

<p>}</p>

<p>/<em> Design: widths, colors, borders, etc... </em>/
.actions-list {</p>

<pre><code>margin: 0;
padding: 0;
</code></pre>

<p>}
.actions-list .action-item {</p>

<pre><code>font-family: Helvetica, Arial, sans-serif;
font-weight: lighter;
cursor: pointer;
background-color: #66bbcc;
border-left: 1px solid rgba(0, 0, 0, 0.2);
color: #000000;
padding-left: 52px;
background-repeat: no-repeat;
background-position: left 10px center;
background-size: 32px;
line-height: 52px;
height: 52px;
max-width: 50px;
</code></pre>

<p>}
.actions-list .action-item:hover {</p>

<pre><code>max-width: 150px;
background-color: #ff9966;
padding-right: 10px;
</code></pre>

<p>}
.actions-list .action-item:first-child {</p>

<pre><code>border: none;
</code></pre>

<p>}</p>

<p>.facebook {</p>

<pre><code>background-image: url(http://www.webdeveasy.com/code/assets/images/facebook.png);
</code></pre>

<p>}
.google {</p>

<pre><code>background-image: url(http://www.webdeveasy.com/code/assets/images/google.png);
</code></pre>

<p>}
.linkedin {</p>

<pre><code>background-image: url(http://www.webdeveasy.com/code/assets/images/linkedin.png);
</code></pre>

<p>}
.picasa {</p>

<pre><code>background-image: url(http://www.webdeveasy.com/code/assets/images/picasa.png);
</code></pre>

<p>}
.twitter {</p>

<pre><code>background-image: url(http://www.webdeveasy.com/code/assets/images/twitter.png);
</code></pre>

<p>}
.wikipedia {</p>

<pre><code>background-image: url(http://www.webdeveasy.com/code/assets/images/wikipedia.png);
</code></pre>

<p>}
```</p>

<p>I hope you will find a good use for it.</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pages Slider With JavaScript And CSS]]></title>
    <link href="http://webdeveasy.com/pages-slider-with-javascript-and-css/"/>
    <updated>2013-08-06T02:37:31+03:00</updated>
    <id>http://webdeveasy.com/pages-slider-with-javascript-and-css</id>
    <content type="html"><![CDATA[<p>In this article I will show you how to build a pages slider that looks like those on our smartphones. At the end we will get this:</p>

<div class="example">
    Slide left to see this in action:
    <br/> 
    <div class="slider">
        <div class="content">
            <div class="page"></div>
            <div class="page"></div>
            <div class="page"></div>
            <div class="page"></div>
            <div class="page"></div>
            <div class="page"></div>
            <div class="page"></div>
            <div class="page"></div>
        </div>
    </div>
</div>


<script type="text/javascript">
    $(function() {
        $('.slider').pagesSliderTouch();
    });
</script>


<!-- more -->


<h2>Slider Markup Structure</h2>

<p>Our slider consist of div contained in another div. The parent div has limited width with overflow set to "hidden". The child div contains the pages and therefore has their total width. This way only one page is visible and in order to move between pages all we have to do is change the child div's position relative to its parent. Important thing to mention is that we won't really change the child div's position property but will use CSS transform property to simulate this. Here is a sketch of the slider markup structure:</p>

<p><img class="center" src="/code/pages-slider-with-javascript-and-css/images/markup.png" title="'Slider Markup Structure'" ></p>

<p>According to this plan, let's write a markup for four pages with relevant CSS properties:
```html Pages slider plugin markup</p>

<div class="slider">
    <div class="content">
        <div class="page"></div>
        <div class="page"></div>
        <div class="page"></div>
        <div class="page"></div>
    </div>
</div>


<p><code>
</code>css Slider plugin style
.slider { overflow: hidden; }
.slider .content { position: relative; }
.slider .content .page { float: left; }
<code>
This CSS is mandatory in order to give our slider the correct appearance. In addition, we have to style the pages. Their style is not mandatory for the plugin behavior and it's only purpose is to make the pages look nice.
</code>css Pages style
.page {</p>

<pre><code>width: 300px;
height: 100px;  
border-radius: 2px;
box-shadow: inset 0 0 6px 0 rgba(0,0,0,0.4);
background-repeat: no-repeat;
background-size: cover;
</code></pre>

<p>}</p>

<p>.page:nth-child(1) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?1');
</code></pre>

<p>}
.page:nth-child(2) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?2');
</code></pre>

<p>}
.page:nth-child(3) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?3');
</code></pre>

<p>}
.page:nth-child(4) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?4');
</code></pre>

<p>}
```
Keep in mind that all the pages must have equal width. In our example, page size is 300px width and 100px height. In order to make this example interesting, each page contains a random image. <br/>
Now all we are left to do is writing the plugin's behavior.</p>

<h2>Slider Behavior</h2>

<p>Our slider behavior is very simple. All we have to do is to bind to mouse down, mouse move and mouse up events, and move the pages accordingly. <br/>
I will start to write this plugin with prototype, so if you are not familiar with prototype, my <a href="http://webdeveasy.com/javascript-prototype" target="_blank">JavaScript Prototype</a> article can be a good reference. Later I will integrate the plugin to jQuery plugin but you can easily integrate it yourself to an AngularJS directive or whatever you like. At the end I will integrate the plugin with <a href="http://eightmedia.github.io/hammer.js" target="_blank">Hammer.js</a> so the plugin will work also with touch gestures. <br/>
Ok, enough talking. Let's write our plugin.</p>

<h2>PagesSlider Initialization and Events Binding</h2>

<p>```javascript PagesSlider initialization and events binding
var PagesSlider = function (slider, options) {</p>

<pre><code>this.slider = slider;
this.content = slider.children().first();
this.currentIndex = 0;
this.pages = this.content.children();
this.slider.width(this.pages.first().width());

var totalWidth = 0;
this.pages.each(function (index, page) {
    totalWidth += $(page).width();
});
this.content.width(totalWidth);

this.bindEvents();
</code></pre>

<p>};
$.extend(PagesSlider.prototype, {</p>

<pre><code>bindEvents: function () {
    this._removeTransition = $.proxy(this.removeTransition, this);
    this._startDrag = $.proxy(this.startDrag, this);
    this._doDrag = $.proxy(this.doDrag, this);
    this._endDrag = $.proxy(this.endDrag, this);

    this.content
        .on('mousedown', this._startDrag)
        .on('transitionend', this._removeTransition);
    $('body')
        .on('mousemove', this._doDrag)
        .on('mouseup', this._endDrag);
},
destroy: function () {
    this.content
        .off('mousedown', this._startDrag)
        .off('transitionend', this._removeTransition);
    $('body')
        .off('mousemove', this._doDrag)
        .off('mouseup', this._endDrag);
}
.
.
.
</code></pre>

<p>});
```
Our constructor gets the slider element as an input. It sets the slider's width to be equal to the first page width and sets content's width to be equal to the pages widths sum. Since all the pages should have the same width and since slider's overflow CSS property was set to hidden, only one page will be visible. The page that will be visible is depending on the content's offset relative to slider.</p>

<h2>startDrag(), doDrag(), endDrag() and removeTransition()</h2>

<p>At the end of the constructor method we bind to 'mousedown', 'mousemove', 'mouseup' and 'transitionend' events. Let's see the implementation of startDrag(), doDrag(), endDrag() and removeTransition():
```javascript startDrag(), doDrag(), endDrag() and removeTransition() implementation
$.extend(PagesSlider.prototype, {</p>

<pre><code>.
.
.
startDrag: function (event) {
    this.enableDrag = true;
    this.dragStartX = event.clientX;
},
doDrag: function (event) {
    if (this.enableDrag) {
        var position = this.pages.eq(this.currentIndex).position();
        var delta = event.clientX - this.dragStartX;

        this.content.css('transform', 'translate3d(' + (delta - position.left) + 'px, 0, 0)');
        event.preventDefault();
    }
},
endDrag: function (event) {
    if (this.enableDrag) {
        this.enableDrag = false;

        var delta = event.clientX - this.dragStartX;
        if (Math.abs(delta) &gt; this.slider.width() / 5) {
            if (delta &lt; 0) {
                this.next();
            } else {
                this.prev();
            }
        } else {
            this.current();
        }
    }
},
removeTransition: function() {
    this.content.css('transition', 'none');
}
.
.
.
</code></pre>

<p>});
```
On startDrag() we enable dragging and store the current X position in order to calculate dragging delta. <br/>
On doDrag() we validate that dragging is enabled (mouse is down) and then calculate the delta and transform the content strip's position according to the delta. <br/>
On endDrag() we disable dragging and move to the new page (previous, next or center the current page). <br/>
The endDrag() method uses next(), prev() and current() methods in order to center the relevant page. Those methods are using CSS animation in order to make smoother transitions. Later, when we use mouse for dragging, we don't need that animation. Therefore, after the transition ends, we remove the animation using removeTransition() method.</p>

<h2>next(), prev() and current()</h2>

<p>```javascript next(), prev() and current() implementation
$.extend(PagesSlider.prototype, {</p>

<pre><code>.
.
.
goToIndex: function (index) {
    var position = this.pages.eq(index).position();

    this.content
        .css('transition', 'all 400ms ease')
        .css('transform', 'translate3d(' + (-1 * (position.left)) + 'px, 0, 0)');

    this.currentIndex = index;
},
current: function () {
    this.goToIndex(this.currentIndex);
},
next: function () {
    if (this.currentIndex &gt;= this.pages.length - 1) {
        this.current();
    } else {
        this.goToIndex(this.currentIndex + 1);
    }
},
prev: function () {
    if (this.currentIndex &lt;= 0) {
        this.current();
    } else {
        this.goToIndex(this.currentIndex - 1);
    }
}
</code></pre>

<p>});
```
The last methods of the plugin are obvious. goToIndex() is a central method that gets a page index and makes a transition to that page. next(), prev() and current() validates that the new page's index is possible (for example, the index cannot be less than 0) and uses goToIndex() to make a transition to the new page.</p>

<p>That's it! Pretty simple.</p>

<h2>Integrate with jQuery Plugin</h2>

<p>Now that we have the plugin code, integrating it into jQuery plugin is not a big deal. If you are not familiar with the <a href="http://webdeveasy.com/jquery-plugin-pattern" target="_blank">jQuery plugin pattern</a>, I advice you to read <a href="http://webdeveasy.com/jquery-plugin-pattern" target="_blank">this post</a>. <br/>
```javascript jQuery plugin integration
(function($) {</p>

<pre><code>$.fn.pagesSlider = function(options) {
    this.each(function(index, slider) {
        var $this = $(slider);
        var pagesSlider = new PagesSlider($this);
        $this.data('pagesSlider', pagesSlider);
    });
    return this;
};
</code></pre>

<p>})(jQuery);
<code>
And in order to invoke the plugin:
</code>javascript jQuery plugin invocation
$(function() {</p>

<pre><code>$('.slider').pagesSlider();
</code></pre>

<p>});
```</p>

<h2>Integrate with Hammer.js</h2>

<p>Hammer.js is a JavaScript library for multi-touch gestures. Although we don't need multi-touch support, we want our users to be able to slide between pages by touch.
Let's download Hammer.js jQuery plugin and initialize Hammer in the scope of the slider before calling the plugin:
```javascript Initialize Hammer.js</p>

<pre><code>$.fn.pagesSliderTouch = function(options) {
    this.hammer();
    this.each(function(index, slider) {
        ...
        ...
</code></pre>

<p>```
Now, all we have to do is to change the events binding to Hammer's events. Changing 'mousedown', 'mousemove' and 'mouseup' to 'dragstart', 'drag' and 'dragend' will do the job.</p>

<h2>Demo &amp; Download</h2>

<ul>
<li><a href="../code/pages-slider-with-javascript-and-css/index.html" target="_blank">Here</a> you can find a demo page.</li>
<li><a href="../code/pages-slider-with-javascript-and-css/pages-slider-with-javascript-and-css.zip" target="_blank">Here</a> you can download the source code.</li>
</ul>


<p>That's all! have fun and don't hesitate to leave your comments!</p>
]]></content>
  </entry>
  
</feed>
