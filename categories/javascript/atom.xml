<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Web Development is Easy!]]></title>
  <link href="http://webdeveasy.com/categories/javascript/atom.xml" rel="self"/>
  <link href="http://webdeveasy.com/"/>
  <updated>2014-03-22T13:54:57+02:00</updated>
  <id>http://webdeveasy.com/</id>
  <author>
    <name><![CDATA[NaorYe]]></name>
    <email><![CDATA[mailto:naorye@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Interceptors in AngularJS and Useful Examples]]></title>
    <link href="http://webdeveasy.com/interceptors-in-angularjs-and-useful-examples/"/>
    <updated>2014-03-08T22:44:14+02:00</updated>
    <id>http://webdeveasy.com/interceptors-in-angularjs-and-useful-examples</id>
    <content type="html"><![CDATA[<p>The <code>$http</code> service of AngularJS allows us to communicate with a backend and make HTTP requests. There are cases where we want to capture every request and manipulate it before sending it to the server. Other times we would like to capture the response and process it before completing the call. Global http error handling can be also a good example of such need. Interceptors are created exactly for such cases. This article will introduce AngularJS interceptors and will provide some useful examples.</p>

<!-- more -->


<h2>What are Interceptors?</h2>

<p>The <code>$httpProvider</code> provider contains an array of interceptors. An interceptor is simply a regular service factory that is registered to that array. This is how we create an interceptor:
```javascript Interceptor declaration
module.factory('myInterceptor', ['$log', function($log) {</p>

<pre><code>$log.debug('$log is here to show you that this is a regular factory with injection');

var myInterceptor = {
    ....
    ....
    ....
};

return myInterceptor;
</code></pre>

<p>}]);
<code>
And then add it by it's name to `$httpProvider.interceptors` array:
</code> javascript add the interceptor to $httpProvider.interceptors
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('myInterceptor');
</code></pre>

<p>}]);
```
Interceptors allow you to:</p>

<ul>
<li><p><strong>Intercept a request by implementing the <code>request</code> function:</strong> This method is called before <code>$http</code> sends the request to the backend, so you can modify the configurations and make other actions. This function receives the request configuration object as a parameter and has to return a configuration object or a promise. Returning an invalid configuration object or promise that will be rejected, will make the <code>$http</code> call to fail.</p></li>
<li><p><strong>Intercept a response by implementing the <code>response</code> function:</strong> This method is called right after <code>$http</code> receives the response from the backend, so you can modify the response and make other actions. This function receives a response object as a parameter and has to return a response object or a promise. The response object includes the request configuration, headers, status and data that returned from the backend. Returning an invalid response object or promise that will be rejected, will make the <code>$http</code> call to fail.</p></li>
<li><p><strong>Intercept request error by implementing the <code>requestError</code> function:</strong> Sometimes a request can't be sent or it is rejected by an interceptor. Request error interceptor captures requests that have been canceled by a previous request interceptor. It can be used in order to recover the request and sometimes undo things that have been set up before a request, like removing overlays and loading indicators, enabling buttons and fields and so on.</p></li>
<li><p><strong>Intercept response error by implementing the <code>responseError</code> function:</strong> Sometimes our backend call fails. Other times it might be rejected by a request interceptor or by a previous response interceptor. In those cases, response error interceptor can help us to recover the backend call.</p></li>
</ul>


<h2>Asynchronous Operations</h2>

<p>Sometimes there is a need to make some asynchronous operations inside the interceptor. Luckily AngularJS allows us to return a promise that will be resolved later. This will defer the request sending in case of request interceptor and will defer the response resolving in case of response interceptor.
```javascript Make asynchronous operations in request interceptor
module.factory('myInterceptor', ['$q', 'someAsyncService', function($q, someAsyncService) {</p>

<pre><code>var requestInterceptor = {
    request: function(config) {
        var deferred = $q.defer();
        someAsyncService.doAsyncOperation().then(function() {
            // Asynchronous operation succeeded, modify config accordingly
            ...
            deferred.resolve(config);
        }, function() {
            // Asynchronous operation failed, modify config accordingly
            ...
            deferred.resolve(config);
        });
        return deferred.promise;
    }
};

return requestInterceptor;
</code></pre>

<p>}]);
<code>
In this example, the request interceptor makes an asynchronous operation and updates the config according to the results. Then it continues with the modified config. If `deferred` is rejected, the http request will fail.   
The same applies for response interceptor:
</code>javascript Make asynchronous operations in response interceptor
module.factory('myInterceptor', ['$q', 'someAsyncService', function($q, someAsyncService) {</p>

<pre><code>var responseInterceptor = {
    response: function(response) {
        var deferred = $q.defer();
        someAsyncService.doAsyncOperation().then(function() {
            // Asynchronous operation succeeded, modify response accordingly
            ...
            deferred.resolve(response);
        }, function() {
            // Asynchronous operation failed, modify response accordingly
            ...
            deferred.resolve(response);
        });
        return deferred.promise;
    }
};

return responseInterceptor;
</code></pre>

<p>}]);
<code>``
Only when</code>deferred<code>is resolved, the request will succeed. If</code>deferred` is rejected, the request will fail.</p>

<h2>Examples</h2>

<p>In this section I'll provide some examples to AngularJS Interceptors in order to give a good understanding of how to use them and how they can help you. Keep in mind that the solutions I provide here are not necessarily the best or the most accurate solutions.</p>

<h3>Session Injector (request interceptor)</h3>

<p>There are two ways of implementing server side authentication. The first one is to use the traditional Cookie-Based Authentication that uses server side cookies to authenticate the user on each request. The other approach is Token-Based Authentication. When the user logs in, he gets <code>sessionToken</code> from the backend. This <code>sessionToken</code> identifies the user in the server and is sent to the server on each request. <br/>
The following <code>sessionInjector</code> adds <code>x-session-token</code> header to each intercepted request (in case the current user is logged in):
```javascript Session Injector
module.factory('sessionInjector', ['SessionService', function(SessionService) {</p>

<pre><code>var sessionInjector = {
    request: function(config) {
        if (!SessionService.isAnonymus)
            config.headers['x-session-token'] = SessionService.token;
        }
        return config;
    }
};
return sessionInjector;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('sessionInjector');
</code></pre>

<p>}]);
<code>
And now creating a get request:
</code>javascript
$http.get('https://api.github.com/users/naorye/repos');
<code>
The configuration object before intercepted by `sessionInjector`:
</code>javascript
{</p>

<pre><code>"transformRequest": [
    null
],
"transformResponse": [
    null
],
"method": "GET",
"url": "https://api.github.com/users/naorye/repos",
"headers": {
    "Accept": "application/json, text/plain, */*"
}
</code></pre>

<p>}
<code>
The configuration object after intercepted by `sessionInjector`:
</code>javascript
{</p>

<pre><code>"transformRequest": [
    null
],
"transformResponse": [
    null
],
"method": "GET",
"url": "https://api.github.com/users/naorye/repos",
"headers": {
    "Accept": "application/json, text/plain, */*",
    "x-session-token": 415954427904
}
</code></pre>

<p>}
```</p>

<h3>Timestamp Marker (request and response interceptors)</h3>

<p>Let's measure the time it takes to get a backend response using interceptors. It is done by adding a timestamp for each request and response:
```javascript Timestamp Marker
module.factory('timestampMarker', [function() {</p>

<pre><code>var timestampMarker = {
    request: function(config) {
        config.requestTimestamp = new Date().getTime();
        return config;
    },
    response: function(response) {
        response.config.responseTimestamp = new Date().getTime();
        return response;
    }
};
return timestampMarker;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('timestampMarker');
</code></pre>

<p>}]);
<code>
And now we can do:
</code>javascript
$http.get('https://api.github.com/users/naorye/repos').then(function(response) {</p>

<pre><code>var time = response.config.responseTimestamp - response.config.requestTimestamp;
console.log('The request took ' + (time / 1000) + ' seconds.');
</code></pre>

<p>});
```
Here you can find an <a href="http://webdeveasy.com/code/interceptors-in-angularjs-and-useful-examples/timestamp-marker.html" target="_blank">example for the Timestamp Marker</a>.</p>

<h3>Request Recover (request error interceptor)</h3>

<p>In order to demonstrate a request error interceptor we have to simulate a situation where a previous interceptor rejects the request. Our request error interceptor will get the rejection reason and will recover the request. <br/>
Let's create two interceptors: <code>requestRejector</code> and <code>requestRecoverer</code>. <br/>
```javascript Request Recoverer
module.factory('requestRejector', ['$q', function($q) {</p>

<pre><code>var requestRejector = {
    request: function(config) {
        return $q.reject('requestRejector');
    }
};
return requestRejector;
</code></pre>

<p>}]);
module.factory('requestRecoverer', ['$q', function($q) {</p>

<pre><code>var requestRecoverer = {
    requestError: function(rejectReason) {
        if (rejectReason === 'requestRejector') {
            // Recover the request
            return {
                transformRequest: [],
                transformResponse: [],
                method: 'GET',
                url: 'https://api.github.com/users/naorye/repos',
                headers: {
                    Accept: 'application/json, text/plain, */*'
                }
            };
        } else {
            return $q.reject(rejectReason);
        }
    }
};
return requestRecoverer;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('requestRejector');
// Removing 'requestRecoverer' will result to failed request
$httpProvider.interceptors.push('requestRecoverer'); 
</code></pre>

<p>}]);
<code>
And now, if we do the following, we will get the log `success` even though `requestRejector` rejected the request:
</code>javascript
$http.get('https://api.github.com/users/naorye/repos').then(function() {</p>

<pre><code>console.log('success');
</code></pre>

<p>}, function(rejectReason) {</p>

<pre><code>console.log('failure');
</code></pre>

<p>});
```
Here you can find an <a href="http://webdeveasy.com/code/interceptors-in-angularjs-and-useful-examples/request-recover.html" target="_blank">example for the Request Recover</a>.</p>

<h3>Session Recoverer (response error interceptor)</h3>

<p>There are times, in our single page application, where the session gets lost. Such situation might happen due to session expiration or a server error. Let's create an interceptor that will recover the session and resend the original request again automatically (for situations where the session expired). <br/>
For the example purposes, let's assume that the http status code for session expiration is 419.
```javascript Session Recoverer
module.factory('sessionRecoverer', ['$q', '$injector', function($q, $injector) {</p>

<pre><code>responseError: function(response) {
    // Session has expired
    if (response.status == 419){
        var SessionService = $injector.get('SessionService');
        var $http = $injector.get('$http');
        var deferred = $q.defer();

        // Create a new session (recover the session)
        // We use login method that logs the user in using the current credentials and
        // returns a promise
        SessionService.login().then(deferred.resolve, deferred.reject);

        // When the session recovered, make the same backend call again and chain the request
        return deferred.promise.then(function() {
            return $http(response.config);
        });
    }
    return $q.reject(response);
}
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('sessionRecoverer');
</code></pre>

<p>}]);
<code>``
This way, whenever a backend call fails due to session expiration,</code>sessionRecoverer` creates a new session and performs the backend call again.</p>

<h2>Summary</h2>

<p>In this article I explained about AngularJS interceptors. I presented <code>request</code>, <code>response</code>, <code>requestError</code> and <code>responseError</code> interceptors and described how and when to use them. I also provided real world useful examples that can help you in your development.</p>

<p>I hope you enjoyed reading this article as much as I enjoyed writing it! <br/>
Good Luck! <br/>
NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service Providers in AngularJS and Logger Implementation]]></title>
    <link href="http://webdeveasy.com/service-providers-in-angularjs-and-logger-implementation/"/>
    <updated>2014-02-08T16:49:33+02:00</updated>
    <id>http://webdeveasy.com/service-providers-in-angularjs-and-logger-implementation</id>
    <content type="html"><![CDATA[<p>In this article I'll explain what a provider is and what is the difference between a provider and other services declaration in AngularJS. Through this article I'll also create a tidy Logger for your AngularJS application.</p>

<!-- more -->


<h2>What is wrong with $log?</h2>

<p>Nothing! Really, $log is doing it's work. It is a simple service for logging, including a default implementation that writes messages into the browser's console. And that's it. But when talking about logging, I'd like a service that will print my messages nicely, something like a timestamp and maybe a hint about where the message was created. I would also like to turn off all the messages during application configuration when running on production, and maybe expose a way to turn it on. I know $logProvider has the <code>debugEnabled(flag)</code> method, but I would like to turn off all the other kinds of messages (like <code>info()</code> and <code>error()</code>) and not only debug. Later on I may want to add colors to my messages and maybe aggregate all the <code>error()</code> messages and send them somehow to me. This is why I was looking to create a new logging mechanism. <br/>
While thinking about a way of implementation, I considered using a <a href="http://docs.angularjs.org/api/AUTO.$provide#decorator" target="_blank">service decorator</a> but then realized that I might want more than modifying the behavior of $log, like add or remove methods, or change the way $log's methods work. Eventually I decided to use a <a href="http://docs.angularjs.org/api/AUTO.$provide#methods_provider" target="_blank">service provider</a>.</p>

<h2>A little about AngularJS services</h2>

<p>This section might be a little confusing, but it is really important to understand. When we call <code>module.provider()</code>, we are actually calling the <code>provider()</code> method of the <code>$provide</code> service. <code>$provide.provider()</code> is exposed on <code>angular.Module</code>. The same is for <code>module.service()</code> and <code>module.factory()</code>, they are methods of <code>$provide</code> service that are exposed on <code>angular.Module</code>. Therefore the following blocks are the same thing:
<code>javascript Calling directly to module.provider(), module.service() and module.factory()
module.provider('providerName', function() { ... });
module.service('serviceName', function() { ... });
module.factory('factoryName', function() { ... });
</code>
```
module.config(['$provide', function($provide) {</p>

<pre><code>$provide.provider('providerName', function() { ... });
</code></pre>

<p>});
module.config(['$provide', function($provide) {</p>

<pre><code>$provide.service('serviceName', function() { ... });
</code></pre>

<p>});
module.config(['$provide', function($provide) {</p>

<pre><code>$provide.factory('factoryName', function() { ... });
</code></pre>

<p>});
<code>
More than that, `$provide.service()` and `$provide.factory()` are actually an easy way to use `$provide.provider()`:
</code> javascript $provide.service() and $provide.factory() are actually $provide.provider()
$provide.service('serviceName', function() {</p>

<pre><code>this.name = 'The Catcher in the Rye';
this.author = 'J. D. Salinger';
</code></pre>

<p>});
// Equals to
$provide.provider('serviceName', function() {</p>

<pre><code>this.$get = function($injector) {
    return $injector.instantiate(function() {
        this.name = 'The Catcher in the Rye';
        this.author = 'J. D. Salinger';
    });
};
</code></pre>

<p>});</p>

<p>$provide.factory('factoryName', function() {</p>

<pre><code>return { name: 'The Catcher in the Rye', author: 'J. D. Salinger' };
</code></pre>

<p>});
// Equals to
$provide.provider('serviceName', function() {</p>

<pre><code>this.$get = function($injector) {
    return $injector.invoke(function() {
        return { name: 'The Catcher in the Rye', author: 'J. D. Salinger' };
    });
};
</code></pre>

<p>});
<code>``
As we all can see, AngularJS only knows service provider (</code>$provide.provider()`) and all other ways of creating services are derived.</p>

<h2>What service provider gives?</h2>

<p>Besides of creating the service, service provider allows to configure the service on <code>module.config()</code> block. Look on the following <code>appColor</code> example service that is defined by a service provider:
<code>`` javascript Sample</code>appColor` service provider
$provide.provider('appColor', function() {</p>

<pre><code>var color = 'Green';
this.setColor = function(newColor) {
    color = newColor;
};
this.$get = function() {
    return color;
};
</code></pre>

<p>});
<code>
Whenever we ask from Angular to inject `appColor`, we get the `color` variable that returned from the `$get` method. But on `module.config()` blocks we can ask for `appColorProvider` which exposes the provider and all it's methods and attributes. This let us configure the service before other code consumes it:
</code> javascript <code>appColor</code> configuration and usage
module.config(['appColorProvider', function(appColorProvider) {</p>

<pre><code>appColorProvider.setColor('Blue');
</code></pre>

<p>});
...
...
module.run(['appColor', function(appColor) {</p>

<pre><code>// Will log: 'Application color is Blue'
console.log('Application color is ' + appColor);
</code></pre>

<p>});
```
As you can see, service provider gave us access to the "provider" part, where we can set methods or variables and which can be accessed during configuration only. And this is what I was looking for when thinking about creating my Logger.</p>

<h2>Creating the Logger!</h2>

<p>I want to create a Logger service that will print my messages in the following formats (according to the supplied arguments):  <br/>
<code>&lt;timestamp&gt; - &lt;context&gt;::&lt;method name&gt;('&lt;message&gt;')</code>
<code>&lt;timestamp&gt; - &lt;context&gt;: &lt;message&gt;</code></p>

<p>Before integrating with Angular, let's create a Logger class that uses $log. First we will create a Logger constructor and a static helper method that will create new instances of Logger.
``` javascript Logger construction
var Logger = function(context) {</p>

<pre><code>this.context = context;
</code></pre>

<p>};
Logger.getInstance = function(context) {</p>

<pre><code>return new Logger(context);
</code></pre>

<p>};
<code>
The constructor gets a context as a parameter.   
I want it to be easy to interpolate variables into the message string. Therefore, let's take Douglas Crockford's &lt;a href="http://javascript.crockford.com/remedial.html" target="_blank"&gt;supplant implementation&lt;/a&gt; and put it as a helper in Logger:
</code> javascript supplant support
Logger.supplant = function(str, o) {</p>

<pre><code>return str.replace(
        /\{([^{}]*)\}/g,
        function (a, b) {
            var r = o[b];
            return typeof r === 'string' || typeof r === 'number' ? r : a;
        }
    );
</code></pre>

<p>};
<code>
Now it is easy to add a method that returns a formatted timestamp:
</code> javascript formatted timestamp on message
Logger.getFormattedTimestamp = function(date) {
   return Logger.supplant('{0}:{1}:{2}:{3}', [</p>

<pre><code>    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
]); 
</code></pre>

<p>};
<code>
Notice that the last two methods are generic methods and you can take them out and put in your `utils` service for example.   
Now we want to write a generic `_log()` method that gets the original method of `$log` (log, info, warn, debug or error) and uses it to print a message according to the given arguments. First I'll show my implementation and then explain:
</code>javascript generic <code>_log()</code> method
Logger.prototype = {</p>

<pre><code>// Supports the following arguments: fnName (optional), message (mandatory), supplantData (optional)
// Length and types of arguments are checked in order to determine the usage
_log: function(originalFn, args) {
    var now  = Logger.getFormattedTimestamp(new Date());
    var message = '', supplantData = [];
    switch (args.length) {
        case 1:
            message = Logger.supplant("{0} - {1}: {2}", [ now, this.context, args[0] ]);
            break;
        case 3:
            supplantData = args[2];
            message = Logger.supplant("{0} - {1}::{2}(\'{3}\')", [ now, this.context, args[0], args[1] ]);
            break;
        case 2:
            if (typeof args[1] === 'string') {
                message = Logger.supplant("{0} - {1}::{2}(\'{3}\')", [ now, this.context, args[0], args[1] ]);
            } else {
                supplantData = args[1];
                message = Logger.supplant("{0} - {1}: {2}", [ now, this.context, args[0] ]);
            }
            break;
    }

    $log[originalFn].call(null, Logger.supplant(message, supplantData));
},
...
</code></pre>

<p>};
<code>``
</code>_log()` method first gets the formatted current date. Then it checks for the arguments length and types and determines which output the user wants to print:</p>

<ol>
<li>If the user supplied one argument, then the argument must be the message itself and <code>_log()</code> will print: <code>&lt;timestamp&gt; - &lt;context&gt;: &lt;message&gt;</code></li>
<li>If the user supplied three arguments, then the first argument is a method name, the second is the message and the third is an object of variables to interpolate with the message. For this, <code>_log()</code> will print: <code>&lt;timestamp&gt; - &lt;context&gt;::&lt;method name&gt;('&lt;message&gt;')</code></li>
<li>If the user provided two arguments, we need to find out whether he supplied a method name or an interpolation object. In order to figure that out, we'll check the type of the last argument. If it is a string, then it has to be the message itself while the first argument is the method name. Otherwise consider the first argument as the message and the second as array of interpolation variables. The output print will be according to this check.</li>
</ol>


<p>At the end, <code>_log()</code> calls the required method on $log with the interpolated message. <br/>
Now the last thing to do is to implement an overrides to <code>log()</code>, <code>info()</code>, <code>warn()</code>, <code>debug()</code> and <code>error()</code>:
```javascript implement $log overrides
Logger.prototype = {</p>

<pre><code>...
log: function() {
    this._log('log', arguments);
},
info: function() {
    this._log('info', arguments);
},
warn: function() {
    this._log('warn', arguments);
},
debug: function() {
    this._log('debug', arguments);
},
error: function() {
    this._log('error', arguments);
}
</code></pre>

<p>};
<code>
Finally we have a Logger! This is how we can use it:
</code> javascript Logger usage example
var logger = Logger.getInstance('Example'); // Name of this file / class / module
logger.log('This is a log'); // Logs: "19:24:1:263 - Example: This is a log"
logger.warn('warn', 'This is a warn'); // Warns: "19:24:1:263 - Example::warn('This is a warn')"
logger.error('This is a {0} error! {1}', [ 'big', 'just kidding' ]); // Shouts: "19:24:1:263 - Example: This is a big error! just kidding"
logger.debug('debug', 'This is a debug for line {0}', [ 8 ]); // Logs: "19:24:1:263 - Example::debug('This is a debug for line 8')"
```
Now we can finally integrate our new Logger with AngularJS service provider!</p>

<h2>Back To AngularJS Service Provider</h2>

<p>I wanted to create Logger provider with the ability of disable all the logs. For that I've created a provider that wraps our Logger implementation and adds a method to LoggerProvider for enable or disable Logger:
``` javascript Logger service provider
module.provider('Logger', [function () {</p>

<pre><code>var isEnabled = true;
this.enabled = function(_isEnabled) {
    isEnabled = !!_isEnabled;
};

// $log injected as a dependency
this.$get = ['$log', function($log) {
    var Logger = ...
    ... // Logger implementation

    return Logger;
}];
</code></pre>

<p>}]);
<code>
The last thing left to do is to change the `_log()` to do nothing if `isEnabled` equals to false:
</code> javascript enable / disable <code>_log()</code>
Logger.prototype = {</p>

<pre><code>_log: function(originalFn, args) {
    if (!isEnabled) {
        return;
    }
    ....
</code></pre>

<p><code>
As you can see, Logger is enabled by default. In order to turn it off we just need to do:
</code>javascript Turn off logger
module.config(['Logger', function(Logger) {</p>

<pre><code>Logger.enabled(false);
</code></pre>

<p>});
```
Thats all!</p>

<h2>Summary</h2>

<p>On this article I discussed the difference between AngularJS factory, service and provider. I showed the similarity and explained that service provider is a base method that all other ways of creating services are derived from. I also explained the options of service provider over other services and the most important thing, created a Logger provider with you!</p>

<p>Here you can find <a href="https://github.com/naorye/angular-ny-logger" target="_blank">Logger GitHub Repository</a> with the source code and a demo.</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Data Model]]></title>
    <link href="http://webdeveasy.com/angularjs-data-model/"/>
    <updated>2013-11-23T20:51:33+02:00</updated>
    <id>http://webdeveasy.com/angularjs-data-model</id>
    <content type="html"><![CDATA[<p>As we already know, AngularJS doesn't come with an out of the box solution for data modeling. In the most abstract way, AngularJS lets us use JSON data as a model in the controller. As the time passed and my application grew, I realized that this modeling method isn't powerful enough to fit my application's needs. In this article I will present the way I dealt with data modeling in my AngularJS application.</p>

<!-- more -->


<h2>Defining a model for controller</h2>

<p>Let's start with a simple example. I would like to display a book view. This is the controller:
```javascript BookController
app.controller('BookController', ['$scope', function($scope) {</p>

<pre><code>$scope.book = {
    id: 1,
    name: 'Harry Potter',
    author: 'J. K. Rowling',
    stores: [
        { id: 1, name: 'Barnes &amp; Noble', quantity: 3},
        { id: 2, name: 'Waterstones', quantity: 2},
        { id: 3, name: 'Book Depository', quantity: 5}
    ]
};
</code></pre>

<p>}]);
<code>
This controller creates a model of book which can be later used in our template:
</code>html template for displaying a book</p>

<div ng-controller="BookController">
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
</div>


<p><code>
In case we would like to get the book data from a backend api, we can also use $http:
</code>javascript BookController with $http
app.controller('BookController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>var bookId = 1;

$http.get('ourserver/books/' + bookId).success(function(bookData) {
    $scope.book = bookData;
});
</code></pre>

<p>}]);
<code>
Notice that bookData is still a JSON object.
Later on we would like to do something with this data. For example, update the book, delete it or even do other operations that are not dealing with the backend, like generate a book image url according to requested size or determining whether the book is available. Those methods can be declared on our controller:
</code>javascript BookController with several book actions
app.controller('BookController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>var bookId = 1;

$http.get('ourserver/books/' + bookId).success(function(bookData) {
    $scope.book = bookData;
});

$scope.deleteBook = function() {
    $http.delete('ourserver/books/' + bookId);
};

$scope.updateBook = function() {
    $http.put('ourserver/books/' + bookId, $scope.book);
};

$scope.getBookImageUrl = function(width, height) {
    return 'our/image/service/' + bookId + '/width/height';
};

$scope.isAvailable = function() {
    if (!$scope.book.stores || $scope.book.stores.length === 0) {
        return false;
    }
    return $scope.book.stores.some(function(store) {
        return store.quantity &gt; 0;
    });
};
</code></pre>

<p>}]);
<code>
And later in our template:
</code>html template for displaying a complete book</p>

<div ng-controller="BookController">
    <div ng-style="{ backgroundImage: 'url(' + getBookImageUrl(100, 100) + ')' }"></div>
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
    <br/>
    Is Available: <span ng-bind="isAvailable() ? 'Yes' : 'No' "></span>
    <br/>
    <button ng-click="deleteBook()">Delete</button>
    <br/>
    <button ng-click="updateBook()">Update</button>
</div>


<p>```</p>

<h2>Sharing a model between controllers</h2>

<p>As long as the book's structure and methods are relevant only to one controller, all is fine and our work here is done. But as the application grows, there might be other controllers that will deal with books. Those controllers will sometimes need to fetch a book, update it, delete it or get it's image url or availability. Therefore we have to share the behaviors of a book between controllers. In order to do this we will use a factory that returns the book's behavior. Before writing this factory, I would like to mention here that we could make the factory return an object that contains helper methods for book (i.e. functions that get a book JSON and do what asked), but I prefer to use <a>prototype</a> for constructing a Book class, which I believe is the right choice:
```javascript Book model service
app.factory('Book', ['$http', function($http) {</p>

<pre><code>function Book(bookData) {
    if (bookData) {
        this.setData(bookData):
    }
    // Some other initializations related to book
};
Book.prototype = {
    setData: function(bookData) {
        angular.extend(this, bookData);
    },
    load: function(id) {
        var scope = this;
        $http.get('ourserver/books/' + bookId).success(function(bookData) {
            scope.setData(bookData);
        });
    },
    delete: function() {
        $http.delete('ourserver/books/' + bookId);
    },
    update: function() {
        $http.put('ourserver/books/' + bookId, this);
    },
    getImageUrl: function(width, height) {
        return 'our/image/service/' + this.book.id + '/width/height';
    },
    isAvailable: function() {
        if (!this.book.stores || this.book.stores.length === 0) {
            return false;
        }
        return this.book.stores.some(function(store) {
            return store.quantity &gt; 0;
        });
    }
};
return Book;
</code></pre>

<p>}]);
<code>
This way all book's behavior is encapsulated in Book service. Now, let's use our shiny Book service in our BookController:
</code>javascript BookController that uses Book model
app.controller('BookController', ['$scope', 'Book', function($scope, Book) {</p>

<pre><code>$scope.book = new Book();
$scope.book.load(1);
</code></pre>

<p>}]);
<code>
As you can see, the controller became very thin. It now creates a Book instance, assigns it to the scope and loads it from the backend. When the book will be loaded, it's properties will be changed and so the template. Keep in mind that other controllers that interact with a book, simply inject the Book service. We have to change the template to use book's methods as well:
</code>html template that uses book instance</p>

<div ng-controller="BookController">
    <div ng-style="{ backgroundImage: 'url(' + book.getImageUrl(100, 100) + ')' }"></div>
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
    <br/>
    Is Available: <span ng-bind="book.isAvailable() ? 'Yes' : 'No' "></span>
    <br/>
    <button ng-click="book.delete()">Delete</button>
    <br/>
    <button ng-click="book.update()">Update</button>
</div>


<p>```
Up to here we saw how to model a data, encapsulate all its methods in one class and share this class between controllers without code duplication.</p>

<h2>Model of the same book in several controllers</h2>

<p>So we have a book model definition and several controllers that work with books. After using this modeling architecture you will notice that there is a big problem.
Up to now we supported several controllers that do operations with books. But what will happen if two controllers will deal with the same book? <br/>
Assume that we have a section with a list of names of all our books and another section with an editable view of a book. We have two controllers, one for each section. The first controller loads the books list and the second controller loads a single book. Our user sees the second section, edit the name of the book and then presses on the "update" button. The update process will succeed and the book name will be changed. But in the books list section the user still sees the old name! What happened actually is that there were two different instances of the same book - one for the books list and one for the editable view. When the user edited the book's name, he actually changed the name property of the book instance that was binded to the editable view. Whereas the book instance that was binded to the books list view didn't changed. <br/>
The solution for this problem is to share the same books instances with any controller that needs them. This way both the books list controller and the editable view controller will hold the same book instance and whenever this instance is changed, the changes will be reflected in all the views. Translating words to actions, we have to create a booksManager service (the letter b is not capital because it is an object and not a Class) that will manage books instances pool and will be responsible for returning instances of books. If the required instance doesn't exist in the pool, the service will create it. If the required instance already exists in the pool, the service will only return it. Keep in mind that all the functions that load instances of books will be defined eventually only in our booksManager service since it has to be the only component that provide books instances.
```javascript booksManager service
app.factory('booksManager', ['$http', '$q', 'Book', function($http, $q, Book) {</p>

<pre><code>var booksManager = {
    _pool: {},
    _retrieveInstance: function(bookId, bookData) {
        var instance = this._pool[bookId];

        if (instance) {
            instance.setData(bookData);
        } else {
            instance = new Book(bookData);
            this._pool[bookId] = instance;
        }

        return instance;
    },
    _search: function(bookId) {
        return this._pool[bookId];
    },
    _load: function(bookId, deferred) {
        var scope = this;

        $http.get('ourserver/books/' + bookId)
            .success(function(bookData) {
                var book = scope._retrieveInstance(bookData.id, bookData);
                deferred.resolve(book);
            })
            .error(function() {
                deferred.reject();
            });
    },
    /* Public Methods */
    /* Use this function in order to get a book instance by it's id */
    getBook: function(bookId) {
        var deferred = $q.defer();
        var book = this._search(bookId);
        if (book) {
            deferred.resolve(book);
        } else {
            this._load(bookId, deferred);
        }
        return deferred.promise;
    },
    /* Use this function in order to get instances of all the books */
    loadAllBooks: function() {
        var deferred = $q.defer();
        var scope = this;
        $http.get('ourserver/books)
            .success(function(booksArray) {
                var books = [];
                booksArray.forEach(function(bookData) {
                    var book = scope._retrieveInstance(bookData.id, bookData);
                    books.push(book);
                });

                deferred.resolve(books);
            })
            .error(function() {
                deferred.reject();
            });
        return deferred.promise;
    },
    /*  This function is useful when we got somehow the book data and we wish to store it or update the pool and get a book instance in return */
    setBook: function(bookData) {
        var scope = this;
        var book = this._search(bookData.id);
        if (book) {
            book.setData(bookData);
        } else {
            book = scope._retrieveInstance(bookData);
        }
        return book;
    },

};
return booksManager;
</code></pre>

<p>}]);
<code>
Our Book service is now without the load method:
</code>javascript Book model without the load method
app.factory('Book', ['$http', function($http) {</p>

<pre><code>function Book(bookData) {
    if (bookData) {
        this.setData(bookData):
    }
    // Some other initializations related to book
};
Book.prototype = {
    setData: function(bookData) {
        angular.extend(this, bookData);
    },
    delete: function() {
        $http.delete('ourserver/books/' + bookId);
    },
    update: function() {
        $http.put('ourserver/books/' + bookId, this);
    },
    getImageUrl: function(width, height) {
        return 'our/image/service/' + this.book.id + '/width/height';
    },
    isAvailable: function() {
        if (!this.book.stores || this.book.stores.length === 0) {
            return false;
        }
        return this.book.stores.some(function(store) {
            return store.quantity &gt; 0;
        });
    }
};
return Book;
</code></pre>

<p>}]);
<code>
Our EditableBookController and BooksListController controllers looks like:
</code>javascript EditableBookController and BooksListController that uses booksManager
app</p>

<pre><code>.controller('EditableBookController', ['$scope', 'booksManager', function($scope, booksManager) {
    booksManager.getBook(1).then(function(book) {
        $scope.book = book
    });
}])
.controller('BooksListController', ['$scope', 'booksManager', function($scope, booksManager) {
    booksManager.loadAllBooks().then(function(books) {
        $scope.books = books
    });
}]);
</code></pre>

<p>```
Notice that the templates remain the same as they still use instances. Now the application will hold only one book instance with id equals to 1 and any change on it will be reflected on all views that use it.</p>

<h2>Summary</h2>

<p>On this article I suggested an architecture for modeling data in AngularJS. First, I presented the default model binding of AngularJS, then I showed how to encapsulate the model's methods and operations so we can share it between different controllers, and finally I explained how to manage our models instances so all the changes will be reflected on all the application views.</p>

<p>I hope this article gave you ideas how to implement your data models. If you have any question, don't hesitate to ask!</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Easy Select Plugin]]></title>
    <link href="http://webdeveasy.com/easy-select-plugin/"/>
    <updated>2013-10-07T19:12:43+02:00</updated>
    <id>http://webdeveasy.com/easy-select-plugin</id>
    <content type="html"><![CDATA[<p>One day I was asked to add a text input component with an ability to choose a value from fixed list. After searching the web, I found several jQuery plugins that was able to solve my needs and much more. But, those components required many dependencies and weighed so much for my simple need. So I decided to write my own plugin. Easy Select requires jQuery only and takes 3kb minified (before gzip):</p>

<div>
    Select a continent: <input class="continent-input" type="text" />
    <script>
        $(function() {
            $('.continent-input').easySelect({
                idKey: 'value',
                textKey: 'name',
                items: [
                    { name: 'Africa', value: 1},
                    { name: 'Antarctica', value: 2},
                    { name: 'Asia', value: 3},
                    { name: 'Australia', value: 4},
                    { name: 'Europe', value: 5},
                    { name: 'North America', value: 6},
                    { name: 'South America', value: 7}
                ]
            });
        });
    </script>
</div>


<!-- more -->


<p>See a <a href="http://webdeveasy.com/code/easy-select-plugin/demo/index.html" target="_blank">demo</a>.</p>

<h2>Getting Started</h2>

<ol>
<li>Download the plugin from <a href="https://github.com/naorye/easy-select/archive/master.zip" target="_blank">here</a>.</li>
<li>Add a reference to jquery.easy-select.js and easy-select.css in your page (located in <code>/dist</code> folder). You can use the minified version instead by using jquery.easy-select.min.js and easy-select.min.css.</li>
<li>In order to use the plugin on text input element:
<code>html Text input element
&lt;input type="text" class="my-input" /&gt;
</code>
```javascript easy-select usage
$('.my-input').easySelect({
 items: [

<pre><code> 1: 'Option 1',
 2: 'Option 2',
 3: 'Option 3'
</code></pre>

<p> ]
});
```</p></li>
</ol>


<h2>Options</h2>

<p>Easy select has a few options:</p>

<h4 style="margin-bottom: 0;">items</h4>


<p>Type: Array of objects<br/>
Default: <code>[]</code> <br/>
Array of items for the select box.</p>

<h4 style="margin-bottom: 0;">idKey</h4>


<p>Type: String <br/>
Default: <code>id</code> <br/>
The name of the attribute that represents the item id.</p>

<h4 style="margin-bottom: 0;">textKey</h4>


<p>Type: String <br/>
Default: <code>text</code> <br/>
The name of the attribute that represents the item text.</p>

<h4 style="margin-bottom: 0;">onSelect</h4>


<p>Type: Function <br/>
Default: <code>null</code> <br/>
A callback function that triggered every time a new item gets selected.</p>

<h2>Methods</h2>

<p>Easy select has also a few useful methods. In order to use them you need to access the API object:
<code>javascript Accessing easy-select API object
$('.my-input').data('easySelect');
</code></p>

<h4>getValue()</h4>

<p>In order to get the selectd text you can read the value of your text input. <code>getValue()</code> method returns the value (or id) of the selected item.
<code>javascript Usage example
$('.my-input').data('easySelect').getValue();
</code></p>

<h4>setItems()</h4>

<p><code>setItems()</code> method lets you change the items list during runtime. This method is useful when you want to load data asynchronously.
```javascript Usage example
$.get('url/to/data').done(function(items) {</p>

<pre><code>$('.my-input').data('easySelect').setItems(items);
</code></pre>

<p>});
```</p>

<h4>destroy()</h4>

<p><code>destroy()</code> method destroys the plugin by removing unnecessary elements and unbinding events.
<code>javascript Usage example
$('.my-input').data('easySelect').destroy();
</code></p>

<h2>Contributing</h2>

<ol>
<li>Visit our git repository: <a href="https://github.com/naorye/easy-select" target="_blank">https://github.com/naorye/easy-select</a></li>
<li>Fork it!</li>
<li>Create your feature branch: <code>git checkout -b my-new-feature</code></li>
<li>Make your changes on the <code>src</code> folder, never on the <code>dist</code> folder</li>
<li>You can use <code>grunt build</code> and <code>grunt preview</code> commands in order to see your changes on the demo</li>
<li>Commit your changes: <code>git commit -m 'Add some feature'</code></li>
<li>Push to the branch: <code>git push origin my-new-feature</code></li>
<li>Submit a pull request</li>
</ol>


<p>I hope some of you will find a good use for it.</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Page Application Authentication]]></title>
    <link href="http://webdeveasy.com/single-page-application-authentication/"/>
    <updated>2013-09-25T23:27:44+03:00</updated>
    <id>http://webdeveasy.com/single-page-application-authentication</id>
    <content type="html"><![CDATA[<p>This article will guide you how to add user authentication to your single page application. On the back end side I will use Node.js and on the front end side I will use AngularJS. Although I used specific frameworks, you may apply the same technique for different back end and frond end frameworks (rails, Backbone, etc...). <br/>
The final application will look like this (without the horrible styling):<!--
--><iframe src="http://spa-auth.herokuapp.com/" width="580px" height="150px" scrolling="no" style="overflow:hidden;margin:0 45px;"></iframe></p>

<!-- more -->


<p>At the beginning of this article I will build an application based on <a target="_blank" href="http://nodejs.org">Node.js</a>, <a target="_blank" href="http://expressjs.com/">express</a>, <a target="_blank" href="http://mongoosejs.com/">mongoose</a> and <a target="_blank" href="http://angularjs.org/">AngularJS</a> and then I will add authentication support. At the end we will have single page application that allows users to login and logout from our system. For this article I chose to implement facebook authentication, but changing this later to other 3rd party or local authentication will be trivial. <br/>
One thing important to mention is that the final application will contain the minimum code required for this guide so don't use it as a boilerplate code, the best thing is to learn from it and implement it yourself in your application.</p>

<h2>Create an application</h2>

<p>At the beginning, let's create a single page application.</p>

<h3>Node.js server: app.js</h3>

<p>First thing we do is loading required modules:
```javascript Load required modules and configurations
var fs = require('fs')</p>

<pre><code>mongoose = require('mongoose'),
http = require('http');
</code></pre>

<p><code>
Then we connect to our mongo database (you should define your own) and load some mongoose models (right now we don't have any model):
</code>javascript Connect to mongo db and load mongoose models
mongoose.connect('<mongodb uri>');</p>

<p>var models_path = __dirname + '/app/models';
fs.readdirSync(models_path).forEach(function(file) {</p>

<pre><code>if (file.substring(-3) === '.js') {
    require(models_path + '/' + file);
}
</code></pre>

<p>});
<code>
Last things to do is to configure express application, define its routes and start it. Express configurations and routes definitions are made in different files in order to keep the application easy to maintain.
</code>javascript Configure express, define routes and start
var app = require('./config/express')(config);
require('./config/routes')(app, config);
http.createServer(app).listen(app.get('port'), function(){</p>

<pre><code>console.log('Express server listening on port ' + app.get('port'));
</code></pre>

<p>});</p>

<p>exports = module.exports = app;
```</p>

<h3>Express configuration: config/express.js</h3>

<p>There is nothing special in this express configurations file. Amongst all the configurations, we:</p>

<ul>
<li>Set our views path to be /app/views</li>
<li>Set our view engine to <a target="_blank" href="https://github.com/visionmedia/ejs">ejs</a></li>
<li>Use <a target="_blank" href="http://kcbanner.github.io/connect-mongo/">connect-mongo</a> as a session store (you need to define your &lt;mongodb uri&gt;)</li>
<li>Define /public as a static folder (this folder will contain our front end application)</li>
</ul>


<p>```javascript express configurations
var express = require('express'),</p>

<pre><code>mongoStore = require('connect-mongo')(express),
path = require('path');
</code></pre>

<p>module.exports = function (config) {</p>

<pre><code>var app = express();

var root = path.normalize(__dirname + '/..');

app.set('showStackError', true);

app.set('port', process.env.PORT || 3000);
app.set('views', root + '/app/views');
app.set('view engine', 'ejs');
app.use(express.favicon());

app.use(express.logger('dev'));

app.use(express.bodyParser());
app.use(express.methodOverride());
app.use(express.cookieParser());

app.use(express.session({
    secret: 'my-session-store',
    store: new mongoStore({
        url: '&lt;mongodb uri&gt;',
        collection : 'sessions'
    })
}));

app.use(express.static(root + '/public'));

app.use(app.router);

if ('development' == app.get('env')) {
    app.use(express.errorHandler());

    app.use(function(req, res, next) {
         console.log(req.url);
         next();
    });
}

return app;
</code></pre>

<p>};
```</p>

<h3>Routes definition: config/routes.js</h3>

<p>Our routes definitions are very simple. We need to be able to serve secured data only for our members as well as unsecured data for all users. Therefore the router handles the following endpoints:</p>

<ul>
<li>GET request on api/secured/* for secured data</li>
<li>GET request on api/* for unsecured data</li>
<li>All other GET requests return the index view (except for static content that was defined on express configurations)</li>
</ul>


<p>```javascript Routes definition
module.exports = function (app, passport, config) {</p>

<pre><code>app.get('api/secured/*',
    function (req, res, next) {
        // Need to filter anonymous users somehow 
        /*if (not logged in) {
            return res.json({ error: 'This is a secret message, login to see it.' });
        }*/
        next();
    },
    function (req, res) {
        res.json({ message: 'This message is only for authenticated users' });
    });


app.get('api/*', function (req, res) {
    res.json({ message: 'This message is known by all' });
});


app.get('/*', function (req, res) {
    res.render('index');
});
</code></pre>

<p>};
```
Notice that GET request on api/secured/* should return error JSON for anonymous users.</p>

<h3>Front end</h3>

<p>Our front end, which consists of AngularJS, has an html markup that contains a secured message and an unsecured message:
```html Markup</p>

<div ng-controller="MessageController">
    Unsecured message: <span ng-bind="messages.unsecured"></span>
    <br/>
    Secured message: <span ng-bind="messages.secured"></span>
</div>


<p>```
At the end we would like the secured message to be displayed only to authenticated users.</p>

<p>This is our MessageController:
```javascript MessageController
app.controller('MessageController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>$scope.messages = {};

$http.get('/api/secured/message').success(function(data) {
    $scope.messages.secured = data.message || data.error;
});

$http.get('/api/message').success(function(data) {
    $scope.messages.unsecured = data.message || data.error;
});
</code></pre>

<p>}]);
```</p>

<p>You can download the application we have so far, without authentication, <a target="_blank" href="../code/single-page-application-authentication/single-page-application-without-authentication.zip">here</a>. In order to run the application, fill in your &lt;mongodb uri&gt; in config/express.js, execute 'npm install' and then execute 'npm start'. <br/>
Now is the time to add authentication.</p>

<h2>Authentication support</h2>

<p>For supporting authentication, we will use <a target="_blank" href="http://passportjs.org/">Passport</a> which is a really simple authentication middleware for Node.js. There are other good authentication middlewares like <a target="_blank" href="http://everyauth.com/">everyauth</a> or <a target="_blank" href="https://github.com/ciaranj/connect-auth">connect-auth</a>, but I find Passport more modular and easy to use. <br/>
Supporting facebook authentication with Passport requires to add "passport" and "passport-facebook" packages to package.json.</p>

<p>Before I continue, I'd like to describe how the whole authentication process is going to be:</p>

<ol>
<li>The first time the user enters the application, he is not authenticated.</li>
<li>The user presses the "Login" button and a new window is opened. Because the authentication process includes redirection to facebook, I decided to open a new window in order to keep the current state of the application window.</li>
<li>This new window leads to an endpoint that triggers Passport and the authentication process begins.</li>
<li>During the authentication process, Passport redirects the user to facebook for authentication. When facebook authentication is completed, facebook redirects the user back to the application which will attempt to obtain an access token. If access was granted, the user will be logged in. Otherwise, authentication has failed.</li>
<li>If authentication succeeds, Passport creates a new user (or loads the user in case of returning user) and establishes a new session. This session will be maintained via a cookie set in the user's browser.</li>
<li>After authentication is completed, Passport redirects the new window to an "after-auth" view that informs the parent opener window about the authentication state and the user data.</li>
<li>The next time the user enters to the application, the cookie will identify the session and the user will become logged in.</li>
</ol>


<p>Therefore, our to do list is:</p>

<ul>
<li>Create User model for representing users</li>
<li>Tell Passport how to create or load user instances according to facebook response</li>
<li>Create an after-auth view for completing the authentication</li>
<li>Create endpoints that triggers the authentication process and renders the after-auth view</li>
</ul>


<p>Now stop talking and let's create the User mongoose model.</p>

<h3>User mongoose model</h3>

<p>```javascript User mongoose model
var mongoose = require('mongoose'),</p>

<pre><code>Schema = mongoose.Schema;
</code></pre>

<p>var UserSchema = new Schema({</p>

<pre><code>name: String,
email: String,
username: String,
user_image: String,
facebook_id: String,
facebook: { },
createdAt: { type: Date, 'default': Date.now }
</code></pre>

<p>});</p>

<p>module.exports = mongoose.model('User', UserSchema);
```
As you can see, the User model is very simple. Except the usual user details, we also want to store the user's facebook id and the whole JSON returned from facebook.</p>

<h3>Fetching the current user</h3>

<p>In order to be able to login using facebook, Passport requires an authentication mechanism (called Strategy). "passport-facebook" package gives us FacebookStrategy class which implements such mechanism. All we have to do is to tell Passport to use FacebookStrategy and implement a method that creates or loads a user according to facebook profile id. <br/>
(Note that in order to use this code, you have to supply your facebook app id and facebook app secret)
```javascript FacebookStrategy for Passport
passport.use(new FacebookStrategy({</p>

<pre><code>    clientID: '&lt;Your facebook app id&gt;',
    clientSecret: '&lt;Your facebook app secret&gt;',
    callbackURL: '/auth/facebook/callback'
}, function(accessToken, refreshToken, profile, done) {
    User.findOne({ 'facebook.id': profile.id }, function (err, user) {
        if (err) { return done(err); }
        if (!user) {
            user = new User({
                name: profile.displayName,
                email: profile.emails[0].value,
                username: profile.username,
                provider_id: profile.id,
                provider: 'facebook',
                facebook: profile._json
            });
            user.save(function (err) {
                if (err) {
                    console.log(err);
                }
                return done(err, user);
            });
        } else {
            return done(err, user);
        }
    });
}));
</code></pre>

<p><code>
When Passport gives us the user's facebook profile, we perform mongodb search for the user according to his facebook profile id. If the user is not found, we create a new user model and save it. Eventually we return the user instance.   
In addition to constructing the user from his facebook profile, we also have to tell Passport how to serialize and deserialize user instance to and from a session:
</code>javascript Serialize and deserialize user instance<br/>
passport.serializeUser(function(user, done) {</p>

<pre><code>done(null, user.id);
</code></pre>

<p>});</p>

<p>passport.deserializeUser(function(id, done) {</p>

<pre><code>User.findOne({ _id: id }, function (err, user) {
    done(err, user);
});
</code></pre>

<p>});
```
When user is authenticated, passport serializes the user and stores the result in a session cookie. When a user with session cookie arrives to the system, Passport deserialize the user instance.</p>

<h3>After-authentication view</h3>

<p>After facebook approves or disapproves the user, Passport tries to obtain access token and renders after-auth view. This view contains a script that passes the login state along with the user data (in case of success login) to the parent window. This is done by defining an accessible method on the application window that knows to handle logins results. Let's take a look on the after-auth view:
```html after-auth view
&lt;!DOCTYPE html>
<html lang="en">
<head></p>

<pre><code>&lt;title&gt;Single Page Application Authentication - Auth Success&lt;/title&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;
</code></pre>

<p></head>
<body></p>

<script type="text/javascript">
    if (window.opener) {
        window.opener.focus();

        var state = '<%= state %>';
        var user = <%- JSON.stringify(user) %>;
        if (window.opener.app &&
            window.opener.app.authState) {
            
            window.opener.app.authState(state, user);
        }
    }
    window.close();
</script>


<p></body>
</html>
```
As you can see, this view contains only script code that notifies the application about the authentication state and the user data. Later we will define the authState() method that handles the result. At the end, the pop-up window is closed.</p>

<p>Now is the time to connect all the actions. Let's see our new endpoints.</p>

<h3>New routes definition</h3>

<p>First, let's take a look on the endpoints that handles the login:
```javascript Login endpoints</p>

<pre><code>app.get('/auth/facebook', passport.authenticate('facebook'));
app.get('/auth/facebook/callback', passport.authenticate('facebook', { successRedirect: '/auth/success', failureRedirect: '/auth/failure' }));
app.get('/auth/success', function(req, res) {
    res.render('after-auth', { state: 'success', user: req.user ? req.user : null });
});
app.get('/auth/failure', function(req, res) {
    res.render('after-auth', { state: 'failure', user: null });
});
</code></pre>

<p><code>
When the user asks for /auth/facebook, Passport redirects the user to facebook which in turn redirects the user back to /auth/facebook/callback (accoring to FacebookStrategy implementation). Then, Passport tries to get access token and redirects to /auth/success or /auth/failure according to the result.   
Both /auth/success and /auth/failure render our after-auth view with different parameters.   
Another endpoint for logout will be DELETE request on /auth:
</code>javascript Logout endpoint
app.delete('/auth', function(req, res) {</p>

<pre><code>req.logout();
res.writeHead(200);
res.end();
</code></pre>

<p>});<br/>
<code>
The last thing to do is to fix our secured data endpoint:
</code>javascript Secured data endpoint
app.get('/api/secured/*',</p>

<pre><code>function (req, res, next) {
    if (!req.user) {
        return res.json({ error: 'This is a secret message, login to see it.' });
    }
    next();
},
function (req, res) {
    res.json({ message: 'This message is only for authenticated users' });
});
</code></pre>

<p>```
First we check whether req.user exists. In case it doesn't, we return an error JSON.</p>

<p>After all our hard work, now is the time to see our authentication in action!</p>

<h2>Authentication in action</h2>

<p>In order to demonstrate our authentication implementation, we have to complete our front end application. Let's create AngularJS service that will be responsible to the user session. The purposes of such service are:</p>

<ul>
<li>Initiate the authentication process</li>
<li>Allow logout</li>
<li>Supply handlers for authentication success / failure and maintain session state
```javascript Session service
app.factory('sessionService', ['$rootScope', '$window', '$http',
  function ($rootScope, $window, $http) {
  var session = {

<pre><code>  init: function () {
      this.resetSession();
  },
  resetSession: function() {
      this.currentUser = null;
      this.isLoggedIn = false;
  },
  facebookLogin: function() {
      var url = '/auth/facebook',
          width = 1000,
          height = 650,
          top = (window.outerHeight - height) / 2,
          left = (window.outerWidth - width) / 2;
      $window.open(url, 'facebook_login', 'width=' + width + ',height=' + height + ',scrollbars=0,top=' + top + ',left=' + left);
  },
  logout: function() {
      var scope = this;
      $http.delete('/auth').success(function() {
          scope.resetSession();
          $rootScope.$emit('session-changed');
      });
  },
  authSuccess: function(userData) {
      this.currentUser = userData;
      this.isLoggedIn = true;
      $rootScope.$emit('session-changed');
  },
  authFailed: function() {
      this.resetSession();
      alert('Authentication failed');
  }
</code></pre>

<p>  };
  session.init();
  return session;
}]);
```
Calling sessionService.facebookLogin() and sessionService.logout() will log us in and out from the application. sessionService.authSuccess() and sessionService.authFailed() are methods that get called whenever the application gets notified about the authentication state. From now on, whenever we like, we can use sessionService.isLoggedIn and sessionService.currentUser in order to know the authentication state and get the current logged in user. Our service also triggers a 'session-changed' event each time the session changed.</p></li>
</ul>


<p>Lt's see now the changes in MessageController
```javascript MessageController
app.controller('MessageController', ['$scope', '$rootScope', '$http',</p>

<pre><code>function($scope, $rootScope, $http) {
    $scope.messages = {};

    function loadMessages() {
        $http.get('/api/secured/message').success(function(data) {
            $scope.messages.secured = data.message || data.error;
        });

        $http.get('/api/message').success(function(data) {
            $scope.messages.unsecured = data.message || data.error;
        });
    }

    var deregistration = $rootScope.$on('session-changed', loadMessages);
    $scope.$on('$destroy', deregistration);

    loadMessages();
}]);
</code></pre>

<p>```
MessageController basically remains the same, except that each time 'session-changed' event is triggered, the controller reloads the messages.</p>

<p>Now is the time to add Login and Logout buttons and bind them to actions. Those buttons will be visible only when necessary.
<code>html Login and logout buttons
&lt;button ng-hide="session.isLoggedIn" ng-click="session.facebookLogin()"&gt;Login&lt;/button&gt;
&lt;span ng-show="session.isLoggedIn" ng-bind="'Hello ' + session.currentUser.name"&gt;&lt;/span&gt;
&lt;button ng-show="session.isLoggedIn" ng-click="session.logout()"&gt;Logout&lt;/button&gt;
</code>
In order the variable "session" to be recognized in the template, we will make the following assignment:
```javascript session assignment to $rootScope
app.run(['$rootScope', 'sessionService', function ($rootScope, sessionService) {</p>

<pre><code>$rootScope.session = sessionService;
</code></pre>

<p>}]);
<code>
Now we have to define the authState() method that handles the result from the authentication pop-up window:
</code>javascript app.authState() definition
app.run(['$rootScope', '$window', 'sessionService', function ($rootScope, $window, sessionService) {</p>

<pre><code>$window.app = {
    authState: function(state, user) {
        $rootScope.$apply(function() {
            switch (state) {
                case 'success':
                    sessionService.authSuccess(user);
                    break;
                case 'failure':
                    sessionService.authFailed();
                    break;
            }

        });
    }
};
</code></pre>

<p>}]);
<code>  
One last thing to do is to determine the authentication state when the application loads. On our template we add a script that assigns the current user (or null) to window.user:
</code>html Assigning the current user to window.user</p>

<script type="text/javascript">
    window.user = <%- JSON.stringify(user) %>;
</script>


<p><code>
Where the "user" variable comes from our endpoint:
</code>javascript Injecting the current user to the view</p>

<pre><code>app.get('/*', function (req, res) {
    res.render('index', { user: req.user ? req.user : null });
});
</code></pre>

<p><code>
And when the front end application loads, we initialize the session according to window.user:
</code>javascript Initiate the front end session state
app.run(['sessionService', '$window', function (sessionService, $window) {</p>

<pre><code>if ($window.user !== null) {
    sessionService.authSuccess($window.user);
}
</code></pre>

<p>}]);
```</p>

<p>Congratulations! Now we have a secured application with facebook authentication!</p>

<h2>Download &amp; GitHub &amp; Demo</h2>

<ul>
<li>Download the application with authentication support <a target="_blank" href="../code/single-page-application-authentication/single-page-application-with-authentication.zip">here</a> (don't forget to run 'npm install' before starting the application with 'npm start')</li>
<li>See a demonstration of the application <a target="_blank" href="http://spa-auth.herokuapp.com/">here</a></li>
<li>Visit the <a href="https://github.com/naorye/spa-auth" target="_blank">GitHub repository</a></li>
</ul>


<p>I hope this article helped you understanding how to add authentication support for your single page application. Feel free to leave comments and questions!</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
</feed>
