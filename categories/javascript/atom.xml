<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Web Development is Easy!]]></title>
  <link href="http://webdeveasy.com/categories/javascript/atom.xml" rel="self"/>
  <link href="http://webdeveasy.com/"/>
  <updated>2013-09-26T02:03:16+03:00</updated>
  <id>http://webdeveasy.com/</id>
  <author>
    <name><![CDATA[NaorYe]]></name>
    <email><![CDATA[mailto:naorye@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Single Page Application Authentication]]></title>
    <link href="http://webdeveasy.com/single-page-application-authentication/"/>
    <updated>2013-09-25T23:27:44+03:00</updated>
    <id>http://webdeveasy.com/single-page-application-authentication</id>
    <content type="html"><![CDATA[<p>This article will guide you how to add user authentication to your single page application. On the back end side I will use Node.js and on the front end side I will use AngularJS. Although I used specific frameworks, you may apply the same technique for different back end and frond end frameworks (rails, Backbone, etc...).</p>

<!-- more -->


<p>At the beginning of this article I will build an application based on <a target="_blank" href="http://nodejs.org">Node.js</a>, <a target="_blank" href="http://expressjs.com/">express</a>, <a target="_blank" href="http://mongoosejs.com/">mongoose</a> and <a target="_blank" href="http://angularjs.org/">AngularJS</a> and then I will add authentication support. At the end we will have single page application that allows users to login and logout from our system. For this article I chose to implement facebook authentication, but changing this later to other 3rd party or local authentication will be trivial. <br/>
One thing important to mention is that the final application will contain the minimum code required for this guide so don't use it as a boilerplate code, the best thing is to learn from it and implement it yourself in your application.</p>

<h2>Create an application</h2>

<p>At the beginning, let's create a single page application.</p>

<h3>Node.js server: app.js</h3>

<p>First thing we do is loading required modules:
```javascript Load required modules and configurations
var fs = require('fs')</p>

<pre><code>mongoose = require('mongoose'),
http = require('http');
</code></pre>

<p><code>
Then we connect to our mongo database (you should define your own) and load some mongoose models (right now we don't have any model):
</code>javascript Connect to mongo db and load mongoose models
mongoose.connect('<mongodb uri>');</p>

<p>var models_path = __dirname + '/app/models';
fs.readdirSync(models_path).forEach(function(file) {</p>

<pre><code>if (file.substring(-3) === '.js') {
    require(models_path + '/' + file);
}
</code></pre>

<p>});
<code>
Last things to do is to configure express application, define its routes and start it. Express configurations and routes definitions are made in different files in order to keep the application easy to maintain.
</code>javascript Configure express, define routes and start
var app = require('./config/express')(config);
require('./config/routes')(app, config);
http.createServer(app).listen(app.get('port'), function(){</p>

<pre><code>console.log('Express server listening on port ' + app.get('port'));
</code></pre>

<p>});</p>

<p>exports = module.exports = app;
```</p>

<h3>Express configuration: config/express.js</h3>

<p>There is nothing special in this express configurations file. Amongst all the configurations, we:</p>

<ul>
<li>Set our views path to be /app/views</li>
<li>Set our view engine to <a target="_blank" href="https://github.com/visionmedia/ejs">ejs</a></li>
<li>Use <a target="_blank" href="http://kcbanner.github.io/connect-mongo/">connect-mongo</a> as a session store (you need to define your &lt;mongodb uri&gt;)</li>
<li>Define /public as a static folder (this folder will contain our front end application)</li>
</ul>


<p>```javascript express configurations
var express = require('express'),</p>

<pre><code>mongoStore = require('connect-mongo')(express),
path = require('path');
</code></pre>

<p>module.exports = function (config) {</p>

<pre><code>var app = express();

var root = path.normalize(__dirname + '/..');

app.set('showStackError', true);

app.set('port', process.env.PORT || 3000);
app.set('views', root + '/app/views');
app.set('view engine', 'ejs');
app.use(express.favicon());

app.use(express.logger('dev'));

app.use(express.bodyParser());
app.use(express.methodOverride());
app.use(express.cookieParser());

app.use(express.session({
    secret: 'my-session-store',
    store: new mongoStore({
        url: '&lt;mongodb uri&gt;',
        collection : 'sessions'
    })
}));

app.use(express.static(root + '/public'));

app.use(app.router);

if ('development' == app.get('env')) {
    app.use(express.errorHandler());

    app.use(function(req, res, next) {
         console.log(req.url);
         next();
    });
}

return app;
</code></pre>

<p>};
```</p>

<h3>Routes definition: config/routes.js</h3>

<p>Our routes definitions are very simple. We need to be able to serve secured data only for our members as well as unsecured data for all users. Therefore the router handles the following endpoints:</p>

<ul>
<li>GET request on api/secured/* for secured data</li>
<li>GET request on api/* for unsecured data</li>
<li>All other GET requests return the index view (except for static content that was defined on express configurations)</li>
</ul>


<p>```javascript Routes definition
module.exports = function (app, passport, config) {</p>

<pre><code>app.get('api/secured/*',
    function (req, res, next) {
        // Need to filter anonymous users somehow 
        /*if (not logged in) {
            return res.json({ error: 'This is a secret message, login to see it.' });
        }*/
        next();
    },
    function (req, res) {
        res.json({ message: 'This message is only for authenticated users' });
    });


app.get('api/*', function (req, res) {
    res.json({ message: 'This message is known by all' });
});


app.get('/*', function (req, res) {
    res.render('index');
});
</code></pre>

<p>};
```
Notice that GET request on api/secured/* should return error JSON for anonymous users.</p>

<h3>Front end</h3>

<p>Our front end, which consists of AngularJS, has an html markup that contains a secured message and an unsecured message:
```html Markup</p>

<div ng-controller="MessageController">
    Unsecured message: <span ng-bind="messages.unsecured"></span>
    <br/>
    Secured message: <span ng-bind="messages.secured"></span>
</div>


<p>```
At the end we would like the secured message to be displayed only to authenticated users.</p>

<p>This is our MessageController:
```javascript MessageController
app.controller('MessageController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>$scope.messages = {};

$http.get('/api/secured/message').success(function(data) {
    $scope.messages.secured = data.message || data.error;
});

$http.get('/api/message').success(function(data) {
    $scope.messages.unsecured = data.message || data.error;
});
</code></pre>

<p>}]);
```</p>

<p>You can download the application we have so far, without authentication, <a target="_blank" href="../code/single-page-application-authentication/single-page-application-without-authentication.zip">here</a>. In order to run the application, fill in your &lt;mongodb uri&gt; in config/express.js, execute 'npm install' and then execute 'npm start'. <br/>
Now is the time to add authentication.</p>

<h2>Authentication support</h2>

<p>For supporting authentication, we will use <a target="_blank" href="http://passportjs.org/">Passport</a> which is a really simple authentication middleware for Node.js. There are other good authentication middlewares like <a target="_blank" href="http://everyauth.com/">everyauth</a> or <a target="_blank" href="https://github.com/ciaranj/connect-auth">connect-auth</a>, but I find Passport more modular and easy to use. <br/>
Supporting facebook authentication with Passport requires to add "passport" and "passport-facebook" packages to package.json.</p>

<p>Before I continue, I'd like to describe how the whole authentication process is going to be:</p>

<ol>
<li>The first time the user enters the application, he is not authenticated.</li>
<li>The user presses the "Login" button and a new window is opened. Because the authentication process includes redirection to facebook, I decided to open a new window in order to keep the current state of the application window.</li>
<li>This new window leads to an endpoint that triggers Passport and the authentication process begins.</li>
<li>During the authentication process, Passport redirects the user to facebook for authentication. When facebook authentication is completed, facebook redirects the user back to the application which will attempt to obtain an access token. If access was granted, the user will be logged in. Otherwise, authentication has failed.</li>
<li>If authentication succeeds, Passport creates a new user (or loads the user in case of returning user) and establishes a new session. This session will be maintained via a cookie set in the user's browser.</li>
<li>After authentication is completed, Passport redirects the new window to an "after-auth" view that informs the parent opener window about the authentication state and the user data.</li>
<li>The next time the user enters to the application, the cookie will identify the session and the user will become logged in.</li>
</ol>


<p>Therefore, our to do list is:</p>

<ul>
<li>Create User model for representing users</li>
<li>Tell Passport how to create or load user instances according to facebook response</li>
<li>Create an after-auth view for completing the authentication</li>
<li>Create endpoints that triggers the authentication process and renders the after-auth view</li>
</ul>


<p>Now stop talking and let's create the User mongoose model.</p>

<h3>User mongoose model</h3>

<p>```javascript User mongoose model
var mongoose = require('mongoose'),</p>

<pre><code>Schema = mongoose.Schema;
</code></pre>

<p>var UserSchema = new Schema({</p>

<pre><code>name: String,
email: String,
username: String,
user_image: String,
facebook_id: String,
facebook: { },
createdAt: { type: Date, 'default': Date.now }
</code></pre>

<p>});</p>

<p>module.exports = mongoose.model('User', UserSchema);
```
As you can see, the User model is very simple. Except the usual user details, we also want to store the user's facebook id and the whole JSON returned from facebook.</p>

<h3>Fetching the current user</h3>

<p>In order to be able to login using facebook, Passport requires an authentication mechanism (called Strategy). "passport-facebook" package gives us FacebookStrategy class which implements such mechanism. All we have to do is to tell Passport to use FacebookStrategy and implement a method that creates or loads a user according to facebook profile id. <br/>
(Note that in order to use this code, you have to supply your facebook app id and facebook app secret)
```javascript FacebookStrategy for Passport
passport.use(new FacebookStrategy({</p>

<pre><code>    clientID: '&lt;Your facebook app id&gt;',
    clientSecret: '&lt;Your facebook app secret&gt;',
    callbackURL: '/auth/facebook/callback'
}, function(accessToken, refreshToken, profile, done) {
    User.findOne({ 'facebook.id': profile.id }, function (err, user) {
        if (err) { return done(err); }
        if (!user) {
            user = new User({
                name: profile.displayName,
                email: profile.emails[0].value,
                username: profile.username,
                provider_id: profile.id,
                provider: 'facebook',
                facebook: profile._json
            });
            user.save(function (err) {
                if (err) {
                    console.log(err);
                }
                return done(err, user);
            });
        } else {
            return done(err, user);
        }
    });
}));
</code></pre>

<p><code>
When Passport gives us the user's facebook profile, we perform mongodb search for the user according to his facebook profile id. If the user is not found, we create a new user model and save it. Eventually we return the user instance.   
In addition to constructing the user from his facebook profile, we also have to tell Passport how to serialize and deserialize user instance to and from a session:
</code>javascript Serialize and deserialize user instance<br/>
passport.serializeUser(function(user, done) {</p>

<pre><code>done(null, user.id);
</code></pre>

<p>});</p>

<p>passport.deserializeUser(function(id, done) {</p>

<pre><code>User.findOne({ _id: id }, function (err, user) {
    done(err, user);
});
</code></pre>

<p>});
```
When user is authenticated, passport serializes the user and stores the result in a session cookie. When a user with session cookie arrives to the system, Passport deserialize the user instance.</p>

<h3>After-authentication view</h3>

<p>After facebook approves or disapproves the user, Passport tries to obtain access token and renders after-auth view. This view contains a script that passes the login state along with the user data (in case of success login) to the parent window. This is done by defining an accessible method on the application window that knows to handle logins results. Let's take a look on the after-auth view:
```html after-auth view
&lt;!DOCTYPE html>
<html lang="en">
<head></p>

<pre><code>&lt;title&gt;Single Page Application Authentication - Auth Success&lt;/title&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;
</code></pre>

<p></head>
<body></p>

<script type="text/javascript">
    if (window.opener) {
        window.opener.focus();

        var state = '<%= state %>';
        var user = <%- JSON.stringify(user) %>;
        if (window.opener.app &&
            window.opener.app.authState) {
            
            window.opener.app.authState(state, user);
        }
    }
    window.close();
</script>


<p></body>
</html>
```
As you can see, this view contains only script code that notifies the application about the authentication state and the user data. Later we will define the authState() method that handles the result. At the end, the pop-up window is closed.</p>

<p>Now is the time to connect all the actions. Let's see our new endpoints.</p>

<h3>New routes definition</h3>

<p>First, let's take a look on the endpoints that handles the login:
```javascript Login endpoints</p>

<pre><code>app.get('/auth/facebook', passport.authenticate('facebook'));
app.get('/auth/facebook/callback', passport.authenticate('facebook', { successRedirect: '/auth/success', failureRedirect: '/auth/failure' }));
app.get('/auth/success', function(req, res) {
    res.render('after-auth', { state: 'success', user: req.user ? req.user : null });
});
app.get('/auth/failure', function(req, res) {
    res.render('after-auth', { state: 'failure', user: null });
});
</code></pre>

<p><code>
When the user asks for /auth/facebook, Passport redirects the user to facebook which in turn redirects the user back to /auth/facebook/callback (accoring to FacebookStrategy implementation). Then, Passport tries to get access token and redirects to /auth/success or /auth/failure according to the result.   
Both /auth/success and /auth/failure render our after-auth view with different parameters.   
Another endpoint for logout will be DELETE request on /auth:
</code>javascript Logout endpoint
app.delete('/auth', function(req, res) {</p>

<pre><code>req.logout();
res.writeHead(200);
res.end();
</code></pre>

<p>});<br/>
<code>
The last thing to do is to fix our secured data endpoint:
</code>javascript Secured data endpoint
app.get('/api/secured/*',</p>

<pre><code>function (req, res, next) {
    if (!req.user) {
        return res.json({ error: 'This is a secret message, login to see it.' });
    }
    next();
},
function (req, res) {
    res.json({ message: 'This message is only for authenticated users' });
});
</code></pre>

<p>```
First we check whether req.user exists. In case it doesn't, we return an error JSON.</p>

<p>After all our hard work, now is the time to see our authentication in action!</p>

<h2>Authentication in action</h2>

<p>In order to demonstrate our authentication implementation, we have to complete our front end application. Let's create AngularJS service that will be responsible to the user session. The purposes of such service are:</p>

<ul>
<li>Initiate the authentication process</li>
<li>Allow logout</li>
<li>Supply handlers for authentication success / failure and maintain session state
```javascript Session service
app.factory('sessionService', ['$rootScope', '$window', '$http',
  function ($rootScope, $window, $http) {
  var session = {

<pre><code>  init: function () {
      this.resetSession();
  },
  resetSession: function() {
      this.currentUser = null;
      this.isLoggedIn = false;
  },
  facebookLogin: function() {
      var url = '/auth/facebook',
          width = 1000,
          height = 650,
          top = (window.outerHeight - height) / 2,
          left = (window.outerWidth - width) / 2;
      $window.open(url, 'facebook_login', 'width=' + width + ',height=' + height + ',scrollbars=0,top=' + top + ',left=' + left);
  },
  logout: function() {
      var scope = this;
      $http.delete('/auth').success(function() {
          scope.resetSession();
          $rootScope.$emit('session-changed');
      });
  },
  authSuccess: function(userData) {
      this.currentUser = userData;
      this.isLoggedIn = true;
      $rootScope.$emit('session-changed');
  },
  authFailed: function() {
      this.resetSession();
      alert('Authentication failed');
  }
</code></pre>

<p>  };
  session.init();
  return session;
}]);
```
Calling sessionService.facebookLogin() and sessionService.logout() will log us in and out from the application. sessionService.authSuccess() and sessionService.authFailed() are methods that get called whenever the application gets notified about the authentication state. From now on, whenever we like, we can use sessionService.isLoggedIn and sessionService.currentUser in order to know the authentication state and get the current logged in user. Our service also triggers a 'session-changed' event each time the session changed.</p></li>
</ul>


<p>Lt's see now the changes in MessageController
```javascript MessageController
app.controller('MessageController', ['$scope', '$rootScope', '$http',</p>

<pre><code>function($scope, $rootScope, $http) {
    $scope.messages = {};

    function loadMessages() {
        $http.get('/api/secured/message').success(function(data) {
            $scope.messages.secured = data.message || data.error;
        });

        $http.get('/api/message').success(function(data) {
            $scope.messages.unsecured = data.message || data.error;
        });
    }

    var deregistration = $rootScope.$on('session-changed', loadMessages);
    $scope.$on('$destroy', deregistration);

    loadMessages();
}]);
</code></pre>

<p>```
MessageController basically remains the same, except that each time 'session-changed' event is triggered, the controller reloads the messages.</p>

<p>Now is the time to add Login and Logout buttons and bind them to actions. Those buttons will be visible only when necessary.
<code>html Login and logout buttons
&lt;button ng-hide="session.isLoggedIn" ng-click="session.facebookLogin()"&gt;Login&lt;/button&gt;
&lt;span ng-show="session.isLoggedIn" ng-bind="'Hello ' + session.currentUser.name"&gt;&lt;/span&gt;
&lt;button ng-show="session.isLoggedIn" ng-click="session.logout()"&gt;Logout&lt;/button&gt;
</code>
In order the variable "session" to be recognized in the template, we will make the following assignment:
```javascript session assignment to $rootScope
app.run(['$rootScope', 'sessionService', function ($rootScope, sessionService) {</p>

<pre><code>$rootScope.session = sessionService;
</code></pre>

<p>}]);
<code>
Now we have to define the authState() method that handles the result from the authentication pop-up window:
</code>javascript app.authState() definition
app.run(['$rootScope', '$window', 'sessionService', function ($rootScope, $window, sessionService) {</p>

<pre><code>$window.app = {
    authState: function(state, user) {
        $rootScope.$apply(function() {
            switch (state) {
                case 'success':
                    sessionService.authSuccess(user);
                    break;
                case 'failure':
                    sessionService.authFailed();
                    break;
            }

        });
    }
};
</code></pre>

<p>}]);
<code>  
One last thing to do is to determine the authentication state when the application loads. On our template we add a script that assigns the current user (or null) to window.user:
</code>html Assigning the current user to window.user</p>

<script type="text/javascript">
    window.user = <%- JSON.stringify(user) %>;
</script>


<p><code>
Where the "user" variable comes from our endpoint:
</code>javascript Injecting the current user to the view</p>

<pre><code>app.get('/*', function (req, res) {
    res.render('index', { user: req.user ? req.user : null });
});
</code></pre>

<p><code>
And when the front end application loads, we initialize the session according to window.user:
</code>javascript Initiate the front end session state
app.run(['sessionService', '$window', function (sessionService, $window) {</p>

<pre><code>if ($window.user !== null) {
    sessionService.authSuccess($window.user);
}
</code></pre>

<p>}]);
```</p>

<p>Congratulations! Now we have a secured application with facebook authentication!</p>

<h2>Download &amp; GitHub &amp; Demo</h2>

<ul>
<li>Download the application with authentication support <a target="_blank" href="../code/single-page-application-authentication/single-page-application-with-authentication.zip">here</a> (don't forget to run 'npm install' before starting the application with 'npm start')</li>
<li>See a demonstration of the application <a target="_blank" href="http://spa-auth.herokuapp.com/">here</a></li>
<li>Visit the <a href="https://github.com/naorye/spa-auth" target="_blank">GitHub repository</a></li>
</ul>


<p>I hope this article helped you understanding how to add authentication support for your single page application. Feel free to leave comments and questions!</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pages Slider With JavaScript And CSS]]></title>
    <link href="http://webdeveasy.com/pages-slider-with-javascript-and-css/"/>
    <updated>2013-08-06T02:37:31+03:00</updated>
    <id>http://webdeveasy.com/pages-slider-with-javascript-and-css</id>
    <content type="html"><![CDATA[<p>In this article I will show you how to build a pages slider that looks like those on our smartphones. At the end we will get this:</p>

<iframe src="http://webdeveasy.com/code/pages-slider-with-javascript-and-css/index.html#touch" width="100%" height="122px" scrolling="no" style="overflow:hidden;"></iframe>


<!-- more -->


<h2>Slider Markup Structure</h2>

<p>Our slider consist of div contained in another div. The parent div has limited width with overflow set to "hidden". The child div contains the pages and therefore has their total width. This way only one page is visible and in order to move between pages all we have to do is change the child div's position relative to its parent. Important thing to mention is that we won't really change the child div's position property but will use CSS transform property to simulate this. Here is a sketch of the slider markup structure:</p>

<p><img class="center" src="/code/pages-slider-with-javascript-and-css/images/markup.png" title="'Slider Markup Structure'" ></p>

<p>According to this plan, let's write a markup for four pages with relevant CSS properties:
```html Pages slider plugin markup</p>

<div class="slider">
    <div class="content">
        <div class="page"></div>
        <div class="page"></div>
        <div class="page"></div>
        <div class="page"></div>
    </div>
</div>


<p><code>
</code>css Slider plugin style
.slider { overflow: hidden; }
.slider .content { position: relative; }
.slider .content .page { float: left; }
<code>
This CSS is mandatory in order to give our slider the correct appearance. In addition, we have to style the pages. Their style is not mandatory for the plugin behavior and it's only purpose is to make the pages look nice.
</code>css Pages style
.page {</p>

<pre><code>width: 300px;
height: 100px;  
border-radius: 2px;
box-shadow: inset 0 0 6px 0 rgba(0,0,0,0.4);
background-repeat: no-repeat;
background-size: cover;
</code></pre>

<p>}</p>

<p>.page:nth-child(1) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?1');
</code></pre>

<p>}
.page:nth-child(2) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?2');
</code></pre>

<p>}
.page:nth-child(3) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?3');
</code></pre>

<p>}
.page:nth-child(4) {</p>

<pre><code>background-image: url('http://www.lorempixum.com/300/100/?4');
</code></pre>

<p>}
```
Keep in mind that all the pages must have equal width. In our example, page size is 300px width and 100px height. In order to make this example interesting, each page contains a random image. <br/>
Now all we are left to do is writing the plugin's behavior.</p>

<h2>Slider Behavior</h2>

<p>Our slider behavior is very simple. All we have to do is to bind to mouse down, mouse move and mouse up events, and move the pages accordingly. <br/>
I will start to write this plugin with prototype, so if you are not familiar with prototype, my <a href="http://webdeveasy.com/javascript-prototype" target="_blank">JavaScript Prototype</a> article can be a good reference. Later I will integrate the plugin to jQuery plugin but you can easily integrate it yourself to an AngularJS directive or whatever you like. At the end I will integrate the plugin with <a href="http://eightmedia.github.io/hammer.js" target="_blank">Hammer.js</a> so the plugin will work also with touch gestures. <br/>
Ok, enough talking. Let's write our plugin.</p>

<h2>PagesSlider Initialization and Events Binding</h2>

<p>```javascript PagesSlider initialization and events binding
var PagesSlider = function (slider, options) {</p>

<pre><code>this.slider = slider;
this.content = slider.children().first();
this.currentIndex = 0;
this.pages = this.content.children();
this.slider.width(this.pages.first().width());

var totalWidth = 0;
this.pages.each(function (index, page) {
    totalWidth += $(page).width();
});
this.content.width(totalWidth);

this.bindEvents();
</code></pre>

<p>};
$.extend(PagesSlider.prototype, {</p>

<pre><code>bindEvents: function () {
    this._removeTransition = $.proxy(this.removeTransition, this);
    this._startDrag = $.proxy(this.startDrag, this);
    this._doDrag = $.proxy(this.doDrag, this);
    this._endDrag = $.proxy(this.endDrag, this);

    this.content
        .on('mousedown', this._startDrag)
        .on('transitionend', this._removeTransition);
    $('body')
        .on('mousemove', this._doDrag)
        .on('mouseup', this._endDrag);
},
destroy: function () {
    this.content
        .off('mousedown', this._startDrag)
        .off('transitionend', this._removeTransition);
    $('body')
        .off('mousemove', this._doDrag)
        .off('mouseup', this._endDrag);
}
.
.
.
</code></pre>

<p>});
```
Our constructor gets the slider element as an input. It sets the slider's width to be equal to the first page width and sets content's width to be equal to the pages widths sum. Since all the pages should have the same width and since slider's overflow CSS property was set to hidden, only one page will be visible. The page that will be visible is depending on the content's offset relative to slider.</p>

<h2>startDrag(), doDrag(), endDrag() and removeTransition()</h2>

<p>At the end of the constructor method we bind to 'mousedown', 'mousemove', 'mouseup' and 'transitionend' events. Let's see the implementation of startDrag(), doDrag(), endDrag() and removeTransition():
```javascript startDrag(), doDrag(), endDrag() and removeTransition() implementation
$.extend(PagesSlider.prototype, {</p>

<pre><code>.
.
.
startDrag: function (event) {
    this.enableDrag = true;
    this.dragStartX = event.clientX;
},
doDrag: function (event) {
    if (this.enableDrag) {
        var position = this.pages.eq(this.currentIndex).position();
        var delta = event.clientX - this.dragStartX;

        this.content.css('transform', 'translate3d(' + (delta - position.left) + 'px, 0, 0)');
        event.preventDefault();
    }
},
endDrag: function (event) {
    if (this.enableDrag) {
        this.enableDrag = false;

        var delta = event.clientX - this.dragStartX;
        if (Math.abs(delta) &gt; this.slider.width() / 5) {
            if (delta &lt; 0) {
                this.next();
            } else {
                this.prev();
            }
        } else {
            this.current();
        }
    }
},
removeTransition: function() {
    this.content.css('transition', 'none');
}
.
.
.
</code></pre>

<p>});
```
On startDrag() we enable dragging and store the current X position in order to calculate dragging delta. <br/>
On doDrag() we validate that dragging is enabled (mouse is down) and then calculate the delta and transform the content strip's position according to the delta. <br/>
On endDrag() we disable dragging and move to the new page (previous, next or center the current page). <br/>
The endDrag() method uses next(), prev() and current() methods in order to center the relevant page. Those methods are using CSS animation in order to make smoother transitions. Later, when we use mouse for dragging, we don't need that animation. Therefore, after the transition ends, we remove the animation using removeTransition() method.</p>

<h2>next(), prev() and current()</h2>

<p>```javascript next(), prev() and current() implementation
$.extend(PagesSlider.prototype, {</p>

<pre><code>.
.
.
goToIndex: function (index) {
    var position = this.pages.eq(index).position();

    this.content
        .css('transition', 'all 400ms ease')
        .css('transform', 'translate3d(' + (-1 * (position.left)) + 'px, 0, 0)');

    this.currentIndex = index;
},
current: function () {
    this.goToIndex(this.currentIndex);
},
next: function () {
    if (this.currentIndex &gt;= this.pages.length - 1) {
        this.current();
    } else {
        this.goToIndex(this.currentIndex + 1);
    }
},
prev: function () {
    if (this.currentIndex &lt;= 0) {
        this.current();
    } else {
        this.goToIndex(this.currentIndex - 1);
    }
}
</code></pre>

<p>});
```
The last methods of the plugin are obvious. goToIndex() is a central method that gets a page index and makes a transition to that page. next(), prev() and current() validates that the new page's index is possible (for example, the index cannot be less than 0) and uses goToIndex() to make a transition to the new page.</p>

<p>That's it! Pretty simple.</p>

<h2>Integrate with jQuery Plugin</h2>

<p>Now that we have the plugin code, integrating it into jQuery plugin is not a big deal. If you are not familiar with the <a href="http://webdeveasy.com/jquery-plugin-pattern" target="_blank">jQuery plugin pattern</a>, I advice you to read <a href="http://webdeveasy.com/jquery-plugin-pattern" target="_blank">this post</a>. <br/>
```javascript jQuery plugin integration
(function($) {</p>

<pre><code>$.fn.pagesSlider = function(options) {
    this.each(function(index, slider) {
        var $this = $(slider);
        var pagesSlider = new PagesSlider($this);
        $this.data('pagesSlider', pagesSlider);
    });
    return this;
};
</code></pre>

<p>})(jQuery);
<code>
And in order to invoke the plugin:
</code>javascript jQuery plugin invocation
$(function() {</p>

<pre><code>$('.slider').pagesSlider();
</code></pre>

<p>});
```</p>

<h2>Integrate with Hammer.js</h2>

<p>Hammer.js is a JavaScript library for multi-touch gestures. Although we don't need multi-touch support, we want our users to be able to slide between pages by touch.
Let's download Hammer.js jQuery plugin and initialize Hammer in the scope of the slider before calling the plugin:
```javascript Initialize Hammer.js</p>

<pre><code>$.fn.pagesSliderTouch = function(options) {
    this.hammer();
    this.each(function(index, slider) {
        ...
        ...
</code></pre>

<p>```
Now, all we have to do is to change the events binding to Hammer's events. Changing 'mousedown', 'mousemove' and 'mouseup' to 'dragstart', 'drag' and 'dragend' will do the job.</p>

<h2>Demo &amp; Download</h2>

<ul>
<li><a href="../code/pages-slider-with-javascript-and-css/index.html" target="_blank">Here</a> you can find a demo page.</li>
<li><a href="../code/pages-slider-with-javascript-and-css/pages-slider-with-javascript-and-css.zip" target="_blank">Here</a> you can download the source code.</li>
</ul>


<p>That's all! have fun and don't hesitate to leave your comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backbone Cleanup]]></title>
    <link href="http://webdeveasy.com/backbone-cleanup/"/>
    <updated>2013-04-30T21:09:00+03:00</updated>
    <id>http://webdeveasy.com/backbone-cleanup</id>
    <content type="html"><![CDATA[<p>Backbone allows our users to browse our website without refreshing the page. Each page the user visits consists of several Backbone views which are replaced whenever the user navigates. Views reflect our data models and interact with each other. This can be done by listening and triggering events which add functionality to the page. Whenever the view is replaced, there is a need to clean up the removed view, unbind events and remove unmanaged structure. <br/>
This article suggests a solution to the views cleanup problem.<!-- more --> <br/>
Keep in mind that this is only a suggestion as Backbone doesn't bind us to a specific solution. Your solution should be the one that fit your application structure and requirements.</p>

<h2>Cleanup Router</h2>

<p>We want to cleanup views. In order to do this, we have to find where and when a view is not relevant anymore. After thinking a little I understood that this resides somewhere inside the router, the place where views are replaced by other views. Actually, we want to cleanup the view <strong>right before</strong> the navigation. Unfortunately, Backbone.Router has no "before-navigate" event, so we have to override Router's 'navigate()' method and do whatever we want before calling the original 'navigate()' method. Let's define the Router's 'currentView' member as a reference to the current visible view. Then we can do:<br/>
```javascript Backbone.CleanupRouter class first sketch
Backbone.CleanupRouter = Backbone.Router.extend({</p>

<pre><code>navigate: function() {
    if (this.currentView) {
        this.currentView.cleanupAll();
        this.currentView = null;
    }
    Backbone.Router.prototype.navigate.apply(this, arguments);
}
</code></pre>

<p>});
<code>
This way, each time the user navigates between pages, the router calls the current view's 'cleanupAll()' method and then do the navigation.   
In order to let instances of such a router to mark the current view, let's add 'markCurrentView()' method:
</code>javascript Backbone.CleanupRouter class second sketch
Backbone.CleanupRouter = Backbone.Router.extend({</p>

<pre><code>navigate: function(fragment) {
    if (this.currentView) {
        this.currentView.cleanupAll();
        this.currentView = null;
    }
    Backbone.Router.prototype.navigate.apply(this, arguments);
},
markCurrentView: function(view) {
    this.currentView = view;
}
</code></pre>

<p>});
<code>
Now, CleanupRouter's instance can be something like:
</code>javascript Backbone.CleanupRouter instance example
var router = Backbone.CleanupRouter.extend({</p>

<pre><code>routes: {
    'page-a': 'pageA'
},
pageA: function() {
    var view = // create a view for page A
    this.markCurrentView(view);
}
</code></pre>

<p>});
<code>
After looking on the original Backbone.Router's 'navigate()' method, I noticed that there are some cases where the navigate exits without replacing the view (for example, navigation to the same current route should do nothing). In such cases, we don't need to cleanup the current view. Let's change our custom 'navigate()' to exit in those cases:
</code>javascript Backbone.CleanupRouter class final sketch
var routeStripper = /<sup>[#\/]/;</sup>
Backbone.CleanupRouter = Backbone.Router.extend({</p>

<pre><code>navigate: function(fragment) {
    // Filter cases where navigate exists without navigate
    if (!Backbone.History.started) return false;
    var frag = (fragment || '').replace(routeStripper, '');
    if (Backbone.history.fragment == frag) return;

    if (this.currentView) {
        this.currentView.cleanupAll();
        this.currentView = null;
    }
    Backbone.Router.prototype.navigate.apply(this, arguments);
},
markCurrentView: function(view) {
    this.currentView = view;
}
</code></pre>

<p>});
```</p>

<h2>Cleanup View</h2>

<p>Now we have to define a view that has a 'cleanupAll()' method. This view should clean up itself when calling 'cleanupAll()':
```javascript Backbone.CleanupView class first sketch
Backbone.CleanupView = Backbone.View.extend({</p>

<pre><code>cleanup: function() {
    // This method should be overridden by each view and should
    // contains all the cleanup commands
},
cleanupAll: function() {
    this.cleanup();
}
</code></pre>

<p>});
<code>
Backbone views can hold nested views. Whenever we cleanup a view, we need to clean also it's nested views. In order to do that, each view should have a reference to all it's nested views. Let's implement this:
</code>javascript Backbone.CleanupView class last sketch
Backbone.CleanupView = Backbone.View.extend({</p>

<pre><code>constructor: function() {
    this.nestedViews = [];
    Backbone.View.prototype.constructor.apply(this, arguments);
},
setNestedView: function(view) {
    this.nestedViews.push(view);
},
cleanup: function() {
    // This method should be overridden
},
cleanupAll: function() {
    for (var i in this.nestedViews) {
        this.nestedViews[i].cleanup();
    }
    this.nestedViews = null;
    this.cleanup();
}
</code></pre>

<p>});
<code>
Now, CleanupView's instance can be something like:
</code>javascript Backbone.CleanupView instance example
var view = Backbone.CleanupView.extend({</p>

<pre><code>render: function() {
    // Render current view
    var nested = // create a nested view which is
                 // also instance of CleanupView
    this.$el.append(nested.$el);

    this.setNestedView(view);
},
cleanup: function() {
    // Cleanup current view only
}
</code></pre>

<p>});
```</p>

<h2>Example</h2>

<p>In order to test our cleanup plugin, I have created a small application that uses it and logs the 'render()' and 'cleanup()' methods. The application contains one router of CleanupRouter type and two views of CleanupView type (with templates):</p>

<p>```javascript Application router
var Router = Backbone.CleanupRouter.extend({</p>

<pre><code>routes: {
    '': 'index',
    'single-view': 'singleView',
    'nested-view': 'nestedView'
},
index: function() {
    this.navigate('single-view', {trigger: true});
},
singleView: function() {
    var view = new SingleView();
    view.render();
    $('#view').empty().append(view.$el);

    this.markCurrentView(view);
},
nestedView: function() {
    var view = new NestedView();
    view.render();
    $('#view').empty().append(view.$el);

    this.markCurrentView(view);
}
</code></pre>

<p>});
```
Our router renders instances of SingleView and NestedView according to the route. After each render we call 'markCurrentView()' in order to mark the current view.</p>

<p>```javascript SingleView view
var SingleView = Backbone.CleanupView.extend({</p>

<pre><code>className: 'single-view',
template: _.template(singleViewTemplate),
render: function() {
    app.log('Render: SingleView (' + this.cid + ')');

    var template = this.template();
    this.$el.html(template);
},
cleanup: function() {
    app.log('Cleanup: SingleView (' + this.cid + ')');
}
</code></pre>

<p>});
<code>
</code>javascript single-view.html template</p>

<h2>Single View</h2>


<p>```
SingleView's template contains only a title. Each time 'render()' and 'cleanup()' are called, the application logs the action.</p>

<p>```javascript NestedView view
var NestedView = Backbone.CleanupView.extend({</p>

<pre><code>className: 'nested-view',
template: _.template(nestedViewTemplate),
events: {
    'click .add-view': 'addView'
},
render: function() {
    app.log('Render: NestedView (' + this.cid + ')');

    var template = this.template();
    this.$el.html(template);
},
cleanup: function() {
    app.log('Cleanup: NestedView (' + this.cid + ')');
},
addView: function() {
    var view = new SingleView();
    this.$el.append(view.$el);
    view.render();
    this.setNestedView(view);
}
</code></pre>

<p>});
<code>
</code>javascript nested-view.html template</p>

<h2>Nested View</h2>


<p><button class="add-view">Add View</button>
```
NestedView's template contains a title and a button. Each time this button is pressed, the view creates and appends to itself a SingleView instance. In addition, by calling 'setNestedView()', the view registers the new SingleView instance to the nested views array. As in SingleView, calls to 'render()' and 'cleanup()' are logged.</p>

<p>You can see the application in action <a target="_blank" href="../code/backbone-cleanup/example/">here</a>. Try to navigate between views and add nested views in order to see in the log how 'render()' and 'cleanup()' take place in the application flow.</p>

<h2>Download &amp; GitHub &amp; Demo</h2>

<ul>
<li><a href="../code/backbone-cleanup/backbone-cleanup.zip" target="_blank">Backbone Cleanup Download</a></li>
<li><a href="https://github.com/naorye/BackboneCleanup" target="_blank">Backbone Cleanup GitHub Repository</a></li>
<li>Example application in action <a target="_blank" href="../code/backbone-cleanup/example/">here</a>.</li>
</ul>


<p>I hope you enjoyed reading this article,</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimize (Concatenate and Minify) RequireJS Projects]]></title>
    <link href="http://webdeveasy.com/optimize-requirejs-projects/"/>
    <updated>2013-04-19T07:32:00+03:00</updated>
    <id>http://webdeveasy.com/optimize-requirejs-projects</id>
    <content type="html"><![CDATA[<p>This article will demonstrate you how to concatenate and minify projects that are based on RequireJS. In this article I'll use several tools that require Node.js. So, if you don't have Node.js yet, install it <a target="_blank" href="http://nodejs.org/">here</a>.</p>

<!-- more -->


<h2>Motivation</h2>

<p>A lot has been written already about RequireJS. This tool allows you to easily separate your JavaScript code into several modules and by this keep your code modular and easy to maintain. Then, you get many JavaScript files that have dependency relation. By adding one script reference to RequireJS in your html file, you can load all the required scripts for your page. <br/>
Still, in production, this is a bad practice to leave all JavaScript files separated. Making many requests, no matter how small the requested files are, take time. This time can be saved by concatenating scripts that reduce the number of requests and save the loading time. <br/>
Another technique to save loading time is to reduce the size of the requested files, a small file can be delivered faster. This process is called <a target="_blank" href="http://en.wikipedia.org/wiki/Minification_%28programming%29">minification</a> and it is done by carefully changing the script's code without changing its behavior and functionality. Such changes can be: removing unnecessary characters like spaces, mangling variables and methods names and so on.
This process of concatenation and minification is called optimization. In addition to JavaScript files optimization, the same methods are used to optimize CSS files. <br/>
RequireJS has two main methods: define() and require(). These methods basically have similar declaration and they both know to load dependencies and then execute a callback function.
Unlike require(), define() is used to store code as a named module. Therefore the define()'s callback function should return a value to define the module. Such modules are called <a target="_blank" href="http://requirejs.org/docs/whyamd.html">AMD</a> (Asynchronous Module Definition).</p>

<p>If you are not familiar with RequireJS or didn't fully understand what I wrote - don't worry. An example is about to come.</p>

<h2>JavaScript Application Optimization</h2>

<p>In this section I will demonstrate the optimization of Addy Osmani's <a target="_blank" href="http://todomvc.com/dependency-examples/backbone_require/">TodoMVC Backbone.js + RequireJS project</a>. Since the TodoMVC project contains many implementations of TodoMVC in different frameworks, I downloaded version 1.1.0 and draw out the Backbone.js + RequireJS application. Download the application from
<a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc.zip">here</a> and extract the zip file. The extracted todo-mvc directory will be our example root path and from now on I'll refer to this directory as &lt;root&gt;. <br/>
If you'll look on &lt;root&gt;/index.html file, you will see it contains only one script tag (and another one if you use Internet Explorer):
```html index.html scripts refrences</p>

<script data-main="js/main" src="js/lib/require/require.js"></script>


<!--[if IE]>
    <script src="js/lib/ie.js"></script>
<![endif]-->


<p>```
In fact, the only tag required for loading the whole project's scripts is the require.js script tag. If you'll launch <a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc/">the project</a> in your browser and look under the network tab of your favorite inspection tool, you will notice that your browser has also loaded other JavaScript files: <br/>
<img class="right" src="/code/optimize-requirejs-projects/loaded-js-files-list.png" title="Loaded JavaScript Files List" alt="Loaded JavaScript Files List"> <br/>
All the scripts marked inside the red square were loaded by RequireJS.</p>

<p>To optimize the project we will use <a target="_blank" href="http://requirejs.org/docs/optimization.html">RequireJS Optimizer</a>. Follow the <a target="_blenk" href="http://requirejs.org/docs/optimization.html#download">download instructions</a>, get r.js and copy it to the &lt;root&gt; directory. jrburke's <a target="_blank" href="https://github.com/jrburke/r.js">r.js</a> is a command line tool that can run AMD based projects, but what is more important, it includes the RequireJS Optimizer which allows us to concatenate and minify scripts.<br/>
RequireJS Optimizer has many usages. It can optimize single JavaScript or single CSS file, it can optimize a whole project or only part of it as well as multi-page application. It can also use different minification engines or no minification at all, and so on. This article has no intention to cover all the possibilities of RequireJS Optimizer, but to demonstrate a usage.</p>

<p>As I mentioned earlier, we will use Node.js in order to run the optimizer. The following command runs it:
<code>bash Run RequireJS Optimizer
$ node r.js -o &lt;arguments&gt;
</code>
There are two ways to supply arguments to the optimizer. One way is to specify arguments on the command line:
<code>bash Arguments on the command line
$ node r.js -o baseUrl=. name=main out=main-built.js
</code>
Other way is to specify a build profile file (relative to the execution folder) that contains the arguments:
<code>bash Arguments on build profile file
$ node r.js -o build.js
</code>
And build.js content:
```javascript Arguments on build profile file
({</p>

<pre><code>baseUrl: ".",
name: "main",
out: "main-built.js"
</code></pre>

<p>})
<code>
I think a build profile file is more readable than command line arguments so I'll use this method. Let's create our &amp;lt;root&amp;gt;/build.js file and see which arguments it contains:
</code>javascript &lt;root&gt;/build.js
({</p>

<pre><code>appDir: './',
baseUrl: './js',
dir: './dist',
modules: [
    {
        name: 'main'
    }
],
fileExclusionRegExp: /^(r|build)\.js$/,
optimizeCss: 'standard',
removeCombined: true,
paths: {
    jquery: 'lib/jquery',
    underscore: 'lib/underscore',
    backbone: 'lib/backbone/backbone',
    backboneLocalstorage: 'lib/backbone/backbone.localStorage',
    text: 'lib/require/text'
},
shim: {
    underscore: {
        exports: '_'
    },
    backbone: {
        deps: [
            'underscore',
            'jquery'
        ],
        exports: 'Backbone'
    },
    backboneLocalstorage: {
        deps: ['backbone'],
        exports: 'Store'
    }
}
</code></pre>

<p>})
```</p>

<p>Understanding all the configurations of RequireJS Optimizer is not the aim of this article, but I want do describe the arguments I used:</p>

<table>
<thead>
<tr>
<th>Argument            </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td>appDir              </td>
<td> The directory that contains the application (the &lt;root&gt; directory). All the files sitting under this directory will be copied from here to the dir argument.</td>
</tr>
<tr>
<td>baseUrl             </td>
<td> A path, relative to appDir, that represents the anchor path for finding files.</td>
</tr>
<tr>
<td>dir                 </td>
<td> This is the output directory which all the application files will be copied to.</td>
</tr>
<tr>
<td>modules             </td>
<td> Array that contains objects. Each object represents a module that should be optimize.</td>
</tr>
<tr>
<td>fileExclusionRegExp </td>
<td> Each file or directory that will be match to this regular expression will not be copied to our output directory. Since we located r.js and build.js under the application directory, we want the optimizer to exclude them. Therefore we set this argument to /&#94;(r|build)&#92;.js$/.</td>
</tr>
<tr>
<td>optimizeCss         </td>
<td> RequireJS Optimizer automatically optimizes our application's CSS files. This argument controls the CSS optimization settings. Allowed values: "none", "standard", "standard.keepLines", "standard.keepComments", "standard.keepComments.keepLines".</td>
</tr>
<tr>
<td>removeCombined      </td>
<td> If true, optimizer will remove concatenated files from the output directory.</td>
</tr>
<tr>
<td>paths               </td>
<td> Relative paths of modules.</td>
</tr>
<tr>
<td>shim                </td>
<td> Configure dependencies and exports for "browser globals" scripts, that do not use define() to declare the dependencies and set a module value.</td>
</tr>
</tbody>
</table>


<p>For more information and for advanced usage of the RequireJS Optimizer, in addition to it's web page provided earlier, you can read the details of all the allowed optimizer configuration options <a target="_blank" href="https://github.com/jrburke/r.js/blob/master/build/example.build.js">here</a>.</p>

<p>Now that we have the build file, lets run the optimizer. Go to the &lt;root&gt; directory and execute the command:</p>

<p><code>bash Run optimizer
$ node r.js -o build.js
</code>
A new folder has created: &lt;root&gt;/dist. It is important to notice that the script &lt;root&gt;/dist/js/main.js now contains all it's combined and minified dependencies. Moreover, &lt;root&gt;/dist/css/base.css is also optimized. <br/>
Running <a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc/dist/">the optimized project</a> launches the application which looks exactly like the non-optimized version. Inspecting the page network traffic will show that only two JavaScript files were loaded:
<img class="right" src="/code/optimize-requirejs-projects/loaded-optimized-js-files-list.png" title="Loaded Optimized JavaScript Files List" alt="Loaded Optimized JavaScript Files List"> <br/>
RequireJs Optimizer reduced the amount of server scripts requests from 13 to 2 and reduced the total scripts size from 164KB to 58.6KB (both require.js and main.js).</p>

<h2>Overhead</h2>

<p>Apparently, after the optimization is over, we don't need a reference to require.js because the scripts are no longer separated and all the dependencies were loaded. <br/>
Still, the optimization process concatenated all our scripts and produced one optimized script file which contains many calls to define() and require(). Therefore, to allow the application work properly, define() and require() must be specified and
implemented somewhere in our application. <br/>
This issue causes a well known overhead: we always have to have any code that implement define() and require(). <strong>This code is not part of our application and it exists only due to our infrastructure considerations.</strong> This problem becomes even bigger when we want to develop a JavaScript library. Such libraries usually have small size comparing to RequireJS itself, and therefore including it in the library will cause a huge overhead.</p>

<p>At the time of writing this article, there isn't any full solution for this overhead, but we can ease it using <a target="_blank" href="https://github.com/jrburke/almond">almond</a>. Almond is a minimalistic AMD loader which implements the RequireJS API, and so, instead of including the RequireJS implementation in our optimized code, we can include almond. <br/>
Nowadays, I am working on an optimizer that will be able to optimize RequireJS applications without overhead, but this is still a new project so there is nothing to show yet.</p>

<h2>Download &amp; Conslusion</h2>

<ul>
<li><a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc.zip">Download</a> <strong>unoptimized</strong> TodoMVC Backbone.js + RequireJS project or <a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc/">See</a> it in action.</li>
<li><a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc-optimized.zip">Download</a> <strong>optimized</strong> TodoMVC Backbone.js + RequireJS project (located under dist folder) or <a target="_blank" href="../code/optimize-requirejs-projects/todo-mvc/dist/">See</a> it in action.</li>
</ul>


<p>After reading this article, I believe you got a solid idea how to optimize your RequireJS application. I'll be glad to answer any question you have.</p>

<p>Good Luck! <br/>
NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object Oriented Programming with JavaScript]]></title>
    <link href="http://webdeveasy.com/object-oriented-programming-with-javascript/"/>
    <updated>2013-03-18T23:01:00+02:00</updated>
    <id>http://webdeveasy.com/object-oriented-programming-with-javascript</id>
    <content type="html"><![CDATA[<p>As we already know, JavaScript is an object oriented language. In this article we will see JavaScript example to <a href="http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29" target="_blank">inheritance</a> and <a href="http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming" target="_blank">subtype polymorphism</a>.<!-- more -->
For solid base, I really recommend to read first about <a href="../javascript-prototype">JavaScript Prototype</a>.</p>

<h2>Base Class</h2>

<p>Lets define an Animal class. First thing to do is to define it's constructor:
```javascript Animal constructor
var Animal = function() {</p>

<pre><code>this.color = "Pink";
</code></pre>

<p>}
<code>
Next, lets define Animal's methods:
</code>javascript Animal methods
Animal.prototype.run = function() {</p>

<pre><code>console.log("Wuuuuuuuuuuuuushhhhhh");
</code></pre>

<p>}
Animal.prototype.sleep = function() {</p>

<pre><code>console.log("ZZZzzzZZZzzzZZZzzzzzz...");
</code></pre>

<p>}
Animal.prototype.eat = function() {</p>

<pre><code>console.log("HmnmnmHmmnmnm..BURP");
</code></pre>

<p>}
<code>
An easy way to write this is to extend Animal.prototype (using &lt;a href="http://api.jquery.com/jQuery.extend/" target="_blank"&gt;jQuery&lt;/a&gt;, &lt;a href="http://underscorejs.org/#extend" target="_blank"&gt;underscore&lt;/a&gt; or your own implementation):
</code>javascript Animal methods using jQuery.extend
$.extend(Animal.prototype, {</p>

<pre><code>run: function() {
    console.log("Wuuuuuuuuuuuuushhhhhh");
},
sleep: function() {
    console.log("ZZZzzzZZZzzzZZZzzzzzz...");
},
eat: function() {
    console.log("HmnmnmHmmnmnm..BURP");
}
</code></pre>

<p>});
```
Great, this looks better. Now we can create animals that can run, sleep and eat.</p>

<h2>Sub Class - Inharitance</h2>

<p>Lets create a Cat which is a sub class of an Animal. First create Cat's constructor:
```javascript Cat constructor
var Cat = function() {</p>

<pre><code>Animal.apply(this, arguments); // Call parent class constructor

this.name = name;
console.log("My name is " + this.name +
            " and my color is " + this.color);
</code></pre>

<p>}
<code>
Next, we want Cat to have Animal's methods, so we need something like:
</code>javascript Cat's prototype gets Animal's prototype
Cat.prototype = Animal.prototype;
```
But this code will cause a problem. Adding new methods to Cat's prototype will add those methods also to Animal (since Cat.prototype and Animal.prototype are now refrence to the same set of methods). <br/>
There are a few ways to solve this problem:</p>

<ol>
    <li>
        Use Object.create method that creates an object based on set of properties:

```javascript Using Object.create
Cat.prototype = Object.create(Animal.prototype);
```
    </li>
    <li>
        Use extend:

```javascript Using extend
$.extend(Cat.prototype, Animal.prototype);
```
    </li>
    <li>
        Dance a little:

```javascript Dancing
var sub = function() { };
sub.prototype = Animal.prototype;
Cat.prototype = new sub();
```
    </li>
</ol>


<p>Lets add methods to Cat:
```javascript Add methods to Cat
$.extend(Cat.prototype, {</p>

<pre><code>drinkMilk: function() {
    consoloe.log("lplplplplplp");
},
fightOtherCat: function() {
    console.log("Mirrrrrrrccchhhhh");
}
</code></pre>

<p>});
<code>
Finally, Cat definition looks like this:
</code>javascript Cat definition
var Cat = function() {</p>

<pre><code>Animal.apply(this, arguments);

this.name = name;
console.log("My name is " + this.name +
            " and my color is " + this.color);
</code></pre>

<p>}
Cat.prototype = Object.create(Animal.prototype);
$.extend(Cat.prototype, {</p>

<pre><code>drinkMilk: function() {
    console.log("lplplplplplp");
},
fightOtherCat: function() {
    console.log("Mirrrrrrrccchhhhh");
}
</code></pre>

<p>});
<code>
So, meybe it will be easier to create inheritance helper:
</code>javascript Inheritance helper
function inherit(base, methods) {</p>

<pre><code>var sub = function() {
    base.apply(this, arguments); // Call base class constructor

    // Call sub class initialize method that will act like a constructor
    this.initialize.apply(this, arguments);
};
sub.prototype = Object.create(base.prototype);
$.extend(sub.prototype, methods);
return sub;
</code></pre>

<p>}
<code>
Now creating Cat using the new helper is really simple and clear:
</code>javascript Cat definition using our inheritance helper
var Cat = inherit(Animal, {</p>

<pre><code>initialize: function(name) {
    this.name = name;
    console.log("My name is " + this.name +
                " and my color is " + this.color);
},
drinkMilk: function() {
    console.log("lplplplplplp");
},
fightOtherCat: function() {
    console.log("Mirrrrrrrccchhhhh");
}
</code></pre>

<p>});
```</p>

<h2>Sub Class - Subtype Polymorphism</h2>

<p>Since cats are purring when they sleep, lets override the sleep method:
```javascript Override base class method
var Cat = inherit(Animal, {</p>

<pre><code>...
...
...
sleep: function() {
    console.log("rrr...rrr...rrr...");
}
</code></pre>

<p>});
<code>
But, what if after purring, cats getting sleep like any other animal?   
Lets call the Animal's sleep method right after purring:
</code>javascript Calling base class method
var Cat = inherit(Animal, {</p>

<pre><code>...
...
...
sleep: function() {
    console.log("rrr...rrr...rrr...");
    Animal.prototype.sleep();
}
</code></pre>

<p>});
```
Now out cat will sleep like any other animal after purring a little.</p>

<h2>Complete Code</h2>

<p>Here is our complete code:
```javascript Complete code
function inherit(base, methods) {</p>

<pre><code>var sub = function() {
    base.apply(this, arguments); // Call base class constructor

    // Call sub class initialize method that will act like a constructor
    this.initialize.apply(this, arguments);
};
sub.prototype = Object.create(base.prototype);
$.extend(sub.prototype, methods);
return sub;
</code></pre>

<p>}</p>

<p>var Animal = function() {</p>

<pre><code>this.color = "Pink";
</code></pre>

<p>}
$.extend(Animal.prototype, {</p>

<pre><code>run: function() {
    console.log("Wuuuuuuuuuuuuushhhhhh");
},
sleep: function() {
    console.log("ZZZzzzZZZzzzZZZzzzzzz...");
},
eat: function() {
    console.log("HmnmnmHmmnmnm..BURP");
}
</code></pre>

<p>});</p>

<p>var Cat = inherit(Animal, {</p>

<pre><code>initialize: function(name) {
    this.name = name;
    console.log("My name is " + this.name +
                " and my color is " + this.color);
},
drinkMilk: function() {
    consoloe.log("lplplplplplp");
},
fightOtherCat: function() {
    console.log("Mirrrrrrrccchhhhh");
},
sleep: function() {
    console.log("rrr...rrr...rrr...");
    Animal.prototype.sleep();
}
</code></pre>

<p>});
```</p>

<h2>Usage</h2>

<p>Since I have a cat, I must create its virtual persona:
<code>javascript My virtual Mutzi
var mutzi = new Cat("Mutzi");
mutzi.run();
mutzi.fightOtherCat();
mutzi.sleep();
</code>
And of course, the result will appear on the console:
<code>
My name is Mutzi and my color is Pink
Wuuuuuuuuuuuuushhhhhh
Mirrrrrrrccchhhhh
rrr...rrr...rrr...
ZZZzzzZZZzzzZZZzzzzzz...
</code></p>

<h2>Summary</h2>

<p>In this article we created the Animal base class. Then we created the Cat sub class by inherit from Animal. Then we added new methods for Cat and at the end we overridden Animal's method and used the base class implementation in our implementation.</p>

<p>I hope you had fun reading this article! <br/>
Any questions -> to me :)</p>
]]></content>
  </entry>
  
</feed>
