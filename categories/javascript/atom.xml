<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Web Development is Easy!]]></title>
  <link href="http://webdeveasy.com/categories/javascript/atom.xml" rel="self"/>
  <link href="http://webdeveasy.com/"/>
  <updated>2014-09-30T00:39:16+03:00</updated>
  <id>http://webdeveasy.com/</id>
  <author>
    <name><![CDATA[NaorYe]]></name>
    <email><![CDATA[mailto:naorye@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Promises and AngularJS $q Service]]></title>
    <link href="http://webdeveasy.com/javascript-promises-and-angularjs-q-service/"/>
    <updated>2014-08-20T12:42:02+03:00</updated>
    <id>http://webdeveasy.com/javascript-promises-and-angularjs-q-service</id>
    <content type="html"><![CDATA[<p>A promise (deferred) is a very simple and powerful tool for asynchronous development. The CommonJS wiki lists <a href="http://wiki.commonjs.org/wiki/Promises" target="_blank">several implementation proposals for the promise pattern</a>. AngularJS has it's own promise implementation that was inspired by <a href="https://github.com/kriskowal/q" target="_blank">Kris Kowal's Q</a> implementation. In this article I'll introduce promises, it's motivation and provide a useful tutorial about working with promises using AngularJS $q promise service.</p>

<!-- more -->


<h2>Promise (Deferred) Motivation</h2>

<p>In JavaScript, asynchronous methods usually use callbacks in order to inform a success or a failure state. The Geolocation api, for example, requires success and failure callbacks in order to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation.getCurrentPosition" target="_blank">get the current position</a>:
```javascript Use callbacks in Geolocation api
function success(position) {
  var coords = position.coords;
  console.log('Your current position is ' + coords.latitude + ' X ' + coords.longitude);
}</p>

<p>function error(err) {
  console.warn('ERROR(' + err.code + '): ' + err.message);
}</p>

<p>navigator.geolocation.getCurrentPosition(success, error);
<code>
Another example is XMLHttpRequest (&lt;a href="https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest" target="_blank"&gt;used to perform ajax calls&lt;/a&gt;). It has `onreadystatechange` callback property that is called whenever the `readyState` attribute changes:
</code>javascript Callback use in XHR
var xhr = new window.XMLHttpRequest();
xhr.open('GET', 'http://www.webdeveasy.com', true);
xhr.onreadystatechange = function() {</p>

<pre><code>if (xhr.readyState === 4) {
    if (xhr.status === 200) {
        console.log('Success');
    }
}
</code></pre>

<p>};
xhr.send();
```
There are many other examples of asynchronicity in JavaScript. Working with callbacks gets complicated when there is a need to synchronize several asynchronous operations.</p>

<h3>Sequentially Executing (Pyramid Of Doom)</h3>

<p>Assume we have <code>N</code> asynchronous methods: <code>async1(success, failure)</code>, <code>async2(success, failure)</code>, ..., <code>asyncN(success, failure)</code> and we want to execute them sequentially, one after another, upon success. Each method gets success and failure callbacks so the code will be:
```javascript execute asynchronous methods sequentially
async1(function() {</p>

<pre><code>async2(function() {
    async3(function() {
        async4(function() {
            ....
                ....
                    ....
                       asyncN(null, null);
                    ....
                ....
            ....
        }, null);
    }, null);
}, null);
</code></pre>

<p>}, null);
```
And here we get the famous <a href="http://javascriptjabber.com/001-jsj-asynchronous-programming/" target="_blank">callback pyramid of doom</a>. Although there are nicer ways to write this code (separate that waterfall into functions for example), this is really hard to read and maintain.</p>

<h3>Parallel Executing</h3>

<p>Assume we have <code>N</code> asynchronous methods: <code>async1(success, failure)</code>, <code>async2(success, failure)</code>, ..., <code>asyncN(success, failure)</code> and we want to execute them parallely and alert a message <strong>at the end of all</strong>. Each method gets success and failure callbacks so the code will be:
```javascript execute asynchronous methods parallel
var counter = N;</p>

<p>function success() {</p>

<pre><code>counter --;
if (counter === 0) {
    alert('done!');
}
</code></pre>

<p>}</p>

<p>async1(success);
async2(success);
....
....
asyncN(success);
<code>``
We declared a counter with initial value equals to the total asynchronous methods to execute. When each method is done, we decrease the counter by one and check whether this was the last execution. This solution is not simple for implementation or maintain, especially when each asynchronous method passes a result value to</code>success()`. In such case we will have to keep the results of each execution.</p>

<p>In both examples, at the time of execution of an asynchronic operation, we had to specify how it will be handled using a success callback. In other words, when we use callbacks, the asynchronic operation needs a reference to its continuation, but this continuation might not be its business. This can lead to tightly coupled modules and services which makes it difficult when reusing or testing code.</p>

<h2>What are Promise and Deferred?</h2>

<p>A deferred represents the result of an asynchronic operation. It exposes an interface that can be used for signaling the state and the result of the operation it represents. It also provides a way to get the associated promise instance. <br/>
A promise provides an interface for interacting with it's related deferred, and so, allows for interested parties to get access to the state and the result of the deferred operation. <br/>
When creating a deferred, it's state is <code>pending</code> and it doesn't have any result. When we <code>resolve()</code> or <code>reject()</code> the deferred, it changes it's state to <code>resolved</code> or <code>rejected</code>. Still, we can get the associated promise immediately after creating a deferred and even assign interactions with it's future result. Those interactions will occur only after the deferred rejected or resolved.</p>

<p>When it comes to coupling, by using promises we can easily create an asynchronic operation before even decide what's going to happen after the resolve. This is why coupling is looser. An asynchronic operation doesn't have to know how it continues, it only has to signal when it is ready.</p>

<p>While deferred has methods for changing the state of an operation, a promise exposes only methods needed to handle and figure out the state, but not methods that can change the state. This is why in a function, returning a promise and not a deferred is a good practice. This prevents from external code to interfere the progress or the state of an operation.</p>

<p>There are several implementations of promises in different languages (JavaScript, JAVA, C++, Python and more) and frameworks (NodeJS, jQuery for JavaScript). AngularJS has a promise implementation under the <code>$q</code> service.</p>

<h2>How to use Deferrers and Promises</h2>

<p>After understanding promises and their motivation, now is the time to see how to use Deferrers and Promises. As said before, there are several implementations of promises, and so, different implementations may have different ways of usage. This section will use <a href="https://docs.angularjs.org/api/ng/service/$q" target="_blank">the AngularJS implementation of promise</a> - the $q service. Still, if you use a different implementation of promises, don't worry, most of the methods I'll describe here are equal for all implementations and if not, there is always an equivalent method.</p>

<h3>Basic usage</h3>

<p>First things first, let's create a deferred!
<code>javascript Creating a deferred
var myFirstDeferred = $q.defer();
</code>
As simple as can be, <code>myFirstDeferred</code> holds a deferred that can be resolved or rejected whenever an asynchronous operation is done. Assume we have an asynchronous method <code>async(success, failure)</code> that gets success and failure callbacks as parameters. When <code>async</code> is done, we want to resolve or reject <code>myFirstDeferred</code> with the result (value or error reason): <br/>
```javascript Resolve and reject a deferred
async(function(value) {</p>

<pre><code>myFirstDeferred.resolve(value);
</code></pre>

<p>}, function(errorReason) {</p>

<pre><code>myFirstDeferred.reject(errorReason);
</code></pre>

<p>});
<code>
Since `$q`'s resolve and reject methods don't depend on a context in order to work, we can simply write:
</code>javascript Resolve and reject a deferred
async(myFirstDeferred.resolve, myFirstDeferred.reject);
<code>
Taking the promise out of `myFirstDeferred` and assigning operations upon success or failure is pretty easy:
</code>javascript Using the promise
var myFirstPromise = myFirstDeferred.promise;</p>

<p>myFirstPromise</p>

<pre><code>.then(function(data) {
    console.log('My first promise succeeded', data);
}, function(error) {
    console.log('My first promise failed', error);
});
</code></pre>

<p><code>
Keep on mind that we can assign the success and failure operations right after creating the deferred (even before calling to `async()`) and that we can assign as many operations as we like:
</code>javascript Using the promise several times
var anotherDeferred = $q.defer();
anotherDeferred.promise</p>

<pre><code>.then(function(data) {
    console.log('This success method was assigned BEFORE calling to async()', data);
}, function(error) {
    console.log('This failure method was assigned BEFORE calling to async()', error);
});
</code></pre>

<p>async(anotherDeferred.resolve, anotherDeferred.reject);</p>

<p>anotherDeferred.promise</p>

<pre><code>.then(function(data) {
    console.log('This ANOTHER success method was assigned AFTER calling to async()', data);
}, function(error) {
    console.log('This ANOTHER failure method was assigned AFTER calling to async()', error);
});
</code></pre>

<p><code>
If `async()` successes, both success methods will occur. The same is for failure.   
A good approach is to wrap asynchronous operations with a function that returns a promise. This way the caller will be able to assign success and failure callbacks the way he likes, but will not be able to interfere the deferred state:
</code>javascript Wrap asynchronous operation
function getData() {</p>

<pre><code>var deferred = $q.defer();
async(deferred.resolve, deferred.reject);
return deferred.promise;
</code></pre>

<p>}
...
... // Later, in a different file
var dataPromise = getData()
...
...
... // Much later, at the bottom of that file :)
dataPromise</p>

<pre><code>.then(function(data) {
    console.log('Success!', data);
}, function(error) {
    console.log('Failure...', error);
});
</code></pre>

<p><code>
Up to here, when we used promises, we assigned both success and failure callbacks. But, there is also a way to assign only success or only failure functions:
</code>javascript Assign only success or failure callback to promise
promise.then(function() {</p>

<pre><code>console.log('Assign only success callback to promise');
</code></pre>

<p>});</p>

<p>promise.catch(function() {</p>

<pre><code>console.log('Assign only failure callback to promise');
// This is a shorthand for `promise.then(null, errorCallback)`
</code></pre>

<p>});
<code>
Passing only success callback to `promise.then()` will assign only success callback and using `promise.catch()` will assign only failure callback. `catch()` is actually a shorthand for `promise.then(null, errorCallback)`.   
In case we want to perform the same operation both on fulfillment or rejection of a promise, we can use `promise.finally()`:
</code>javascript Using finally
promise.finally(function() {</p>

<pre><code>console.log('Assign a function that will be invoked both upon success and failure');
</code></pre>

<p>});
<code>
This is equivalent to:
</code>javascript
var callback = function() {</p>

<pre><code>console.log('Assign a function that will be invoked both upon success and failure');
</code></pre>

<p>};
promise.then(callback, callback);
```</p>

<h3>Chaining values and promises</h3>

<p>Assume we have an asynchronous function <code>async()</code> that returns a promise. I have this interesting block of code:
```javascript values chaining
var promise1 = async();
var promise2 = promise1.then(function(x) {</p>

<pre><code>return x+1;
</code></pre>

<p>});
<code>
As you can understand from that code, `promise1.then()` returns another promise, and I named it `promise2`. When `promise1` is resolved with a value `x`, the success callback executes and returns `x+1`. At this point `promise2` is resolved with `x+1`.   
Another similar example:   
</code>javascript values chaining
var promise2 = async().then(function(data) {</p>

<pre><code>console.log(data);
... // Do something with data
// Returns nothing!
</code></pre>

<p>});
<code>
Here, when the promise that returned from `async()` is resolved, the success callback does it's job and then `promise2` is resolved with no data (`undefined`).   
As you can see, ***promises can chain values and are always resolved after the callback occurs with the returned value***.   
In order to demonstrate it, here is a silly example that uses promises (there is no really a need to use promises here):
</code>javascript values chaining example
// Let's imagine this is really an asynchronous function
function async(value) {</p>

<pre><code>var deferred = $q.defer();
var asyncCalculation = value / 2;
deferred.resolve(asyncCalculation);
return deferred.promise;
</code></pre>

<p>}</p>

<p>var promise = async(8)</p>

<pre><code>.then(function(x) {
    return x+1;
})
.then(function(x) {
    return x*2;
})
.then(function(x) {
    return x-1;
});
</code></pre>

<p>promise.then(function(x) {</p>

<pre><code>console.log(x);
</code></pre>

<p>});
<code>``
This promises chain starts with calling to</code>async(8)<code>which fulfills the promise with the value</code>4<code>. This value passes through all the success callbacks and so the value</code>9<code>is logged (</code>(8 / 2 + 1) * 2 - 1`).</p>

<p>What happens if we chain another promise (and not a value)? Assume we have two asynchronous functions, <code>async1()</code> and <code>async2()</code>, each returns a promise. Let's see the following:
```javascript promises chaining
var promise = async1()</p>

<pre><code>.then(function(data) {
    // Assume async2() needs the response of async1() in order to work
    var async2Promise = async2(data);
    return async2Promise;
</code></pre>

<p>});
<code>
Here, unlike the previous example, the success callback performs another asynchronous operation and returns a promise. The value returned from `async1().then()` is a promise as expected, but now it can be resolved or rejected according to `async2Promise` and with it's resolve value or reject reason.   
Since `async2()` gets `data` as a parameter which is the value that `async1()` is resolved with, and since `async2()` returns a promise, we can simply write:
</code>javascript promises chaining
var promise = async1()</p>

<pre><code>.then(async2);
</code></pre>

<p><code>
Here is another demonstration (again, the usage of promises in `async1()` and `async2()` is not mandatory and for demonstration purposes only):
</code>javascript promises chaining example
// Let's imagine those are really asynchronous functions
function async1(value) {</p>

<pre><code>var deferred = $q.defer();
var asyncCalculation = value * 2;
deferred.resolve(asyncCalculation);
return deferred.promise;
</code></pre>

<p>}
function async2(value) {</p>

<pre><code>var deferred = $q.defer();
var asyncCalculation = value + 1;
deferred.resolve(asyncCalculation);
return deferred.promise;
</code></pre>

<p>}</p>

<p>var promise = async1(10)</p>

<pre><code>.then(function(x) {
    return async2(x);
});
</code></pre>

<p>promise.then(function(x) {</p>

<pre><code>console.log(x);
</code></pre>

<p>});
<code>
First, we call `async1(10)` which fulfills the promise and resolves it with the value `20`. Then the success callback is executed and `async2(20)` returns a promise that is fulfilled with the value `21`. Therefore `promise` is resolved with the value `21` and this is what logged.   
A nice thing is that I can write the same example but with more readable code:
</code>javascript promises chaining - readable
function logValue(value) {</p>

<pre><code>console.log(value);
</code></pre>

<p>}</p>

<p>async1(10)</p>

<pre><code>.then(async2)
.then(logValue);
</code></pre>

<p><code>
It is easy to see that first we call to `async1()`, then we call to `async2()` and at the end we call to `logValue()`. Each method gets the previous resolved value as a parameter. Naming functions with proper names will also make it easy to understand.   
All the previous examples with promises chaining were pretty optimistic since they all succeeded. But in case a promise is rejected for any reason, the chained promise will also be rejected:
</code>javascript promises chaining example
// Let's imagine those are really asynchronous functions
function async1(value) {</p>

<pre><code>var deferred = $q.defer();
var asyncCalculation = value * 2;
deferred.resolve(asyncCalculation);
return deferred.promise;
</code></pre>

<p>}
function async2(value) {</p>

<pre><code>var deferred = $q.defer();
deferred.reject('rejected for demonstration!');
return deferred.promise;
</code></pre>

<p>}</p>

<p>var promise = async1(10)</p>

<pre><code>.then(function(x) {
    return async2(x);
});
</code></pre>

<p>promise.then(</p>

<pre><code>function(x) { console.log(x); },
function(reason) { console.log('Error: ' + reason); });
</code></pre>

<p><code>
As you can understand from this example, `Error: rejected for demonstration!` will be logged eventually.
***Promises can chain promises and are resolved or rejected according to the chained promise (with the chained promise resolve value or reject reason)***.    
Here is a more advanced example of promises chaining:
</code>javascript promises chaining advanced example
async1()</p>

<pre><code>.then(async2)
.then(async3)
.catch(handleReject)
.finally(freeResources);
</code></pre>

<p><code>``
In this example we invoked</code>async1()<code>,</code>async2()<code>and</code>async3()<code>one after another, synchronously. In case of any rejection in any one of those methods, the success invocation will stop and</code>handleReject()<code>will occur. At the end,</code>freeResources()<code>will occur no matter of success and failure. For instance, if</code>async2()<code>will return a rejected promise,</code>async3()<code>will not occur and</code>handleReject()<code>will be invoked with the rejection reason of</code>async2()<code>. And at the end</code>freeResources()` will occur.</p>

<h3>Useful methods</h3>

<p><code>$q</code> has several helper methods that can be a great help when using promises. As I said before, other promises implementations have the same methods, probably with a different name.</p>

<p>Sometimes we need to return a rejected promise. Instead of creating a new promise and rejecting it, we can use <a href="https://docs.angularjs.org/api/ng/service/$q#reject" target="_blank">$q.reject(reason)</a>. <code>$q.reject(reason)</code> returns a rejected promise with a reason. Example:
```javascript $q.reject(reason) example
var promise = async().then(function(value) {</p>

<pre><code>    if (isSatisfied(value)) {
        return value;
    } else {
        return $q.reject('value is not satisfied');
    }
}, function(reason) {
    if (canRecovered(reason)) {
        return newPromiseOrValue;
    } else {
        return $q.reject(reason);
    }
});
</code></pre>

<p><code>``
If</code>async()<code>is resolved with a satisfied value, the value is chained and thus</code>promise<code>will be resolved with it. If the value is not satisfied, a rejected promise is chained and</code>promise<code>will be rejected.
If</code>async()<code>is rejected with a reason that can be recovered, a new value or promise will be chained. If the reason cannot be recovered, a rejected promise is chained and eventually</code>promise` will be rejected.</p>

<p>Similar to <code>$q.reject(reason)</code>, sometimes we need to return a resolved promise with a value. Instead of creating a new promise and resolving it, we can use <a href="https://docs.angularjs.org/api/ng/service/$q#when" target="_blank">$q.when(value)</a>.
```javascript using $q.when(value)
function getDataFromBackend(query) {</p>

<pre><code>var data = searchInCache(query);
if (data) {
    return $q.when(data);
} else {
    return makeAsyncBackendCall(query);
}
</code></pre>

<p>}
<code>
In this example I wrote a function that should retrieve a data from my backend. But, before performing the backend call, the function searches the data in the cache. Since I want this function to always return a promise, in case the data is found in the cache, the function returns `$q.when(data)`.   
A cool thing with `$q.when(value)` is that if `value` is a 3rd party thenable promise (like jQuery's Deferred), this method can wrap it and convert it into a $q promise. This way we can easily use other promises implementations with AngularJS.   
`$.ajax()` of jQuery, for example, returns such thenable promise. The following converts it into angular $q promise:
</code>javascript using $q.when(jQueryPromise)
var jQueryPromise = $.ajax({</p>

<pre><code>...
...
...
</code></pre>

<p>});
var angularPromise = $q.when(jQueryPromise);
```</p>

<p>Sometimes we need to perform several asynchronous operations, no matter the order, and to be notified when they all done. <a href="https://docs.angularjs.org/api/ng/service/$q#all" target="_blank">$q.all(promisesArr)</a> can help us with that. Assume we have <code>N</code> methods that return promises: <code>async1(), ..., asyncN()</code>. The following code will log <code>done</code> only when all operations are resolved successfully:
```javascript $q.all(promisesArr) example
var allPromise = $q.all([</p>

<pre><code>async1(),
async2(),
....
....
asyncN()
</code></pre>

<p>]);</p>

<p>allPromise.then(function(values) {</p>

<pre><code>var value1 = values[0],
    value2 = values[1],
    ....
    ....
    valueN = values[N];

    console.log('done');
</code></pre>

<p>});
<code>``
</code>$q.all(promisesArr)<code>returns a promise that is resolved only when all the promises in</code>promisesArr` are resolved.
Keep in mind that if any of the promises is rejected, the resulting promise will be rejected as well.</p>

<p>Up to here we have learned how to create a deferred, how to reject and resolve it and how to get an access to it's promise. We also seen some useful helping methods that can make our code cleaner and more readable. I think that now is the time for a practical tutorial.</p>

<h2>Promises tutorial using $q service</h2>

<p>Let's say we have an amazing application with an amazing registration form. In order to register, a user has to supply his current geolocation coordinates, his photo and a username. To perform the registration action, our backend architecture requires the following from the frontend:</p>

<ol>
    <li>Provide geolocation longitude and latitude if possible</li>
    <li>Upload the user photo to our photos storage server and provide a url of it</li>
    <li>Reserve the username upon username selection and provide username reservation id</li>
</ol>


<p>For supporting that, let's create the following simple functions (I decided to make this separation of functions in order to explain better). Look carefully and see that those methods are asynchronous and this is where promises come in:</p>

<h3>Function that retrieves the current geolocation coordinates</h3>

<p>```javascript getGeolocationCoordinates()
function getGeolocationCoordinates() {</p>

<pre><code>var deferred = $q.defer();
navigator.geolocation.getCurrentPosition(
    function(position) { deferred.resolve(position.coords); },
    function(error) { deferred.resolve(null); }
);
return deferred.promise;
</code></pre>

<p>}
<code>``
</code>getGeolocationCoordinates()<code>declares a deferred and then asks the browser for the current position. Since the geolocation coordinates are not mandatory, both the success and failure callbacks that are provided to</code>navigator.geolocation.getCurrentPosition()<code>resolve the deferred with some result. In case of failure the result will be</code>null`. At the end, the deferred's promise is returned.</p>

<h3>Function that reads a local file and returns it's content</h3>

<p>```javascript readFile()
function readFile(fileBlob) {</p>

<pre><code>var deferred = $q.defer();
var reader = new FileReader();
reader.onload = function () { deferred.resolve(reader.result); };
reader.onerror = function () { deferred.reject(); };
try {
    reader.readAsDataURL(fileBlob);
} catch (e) {
    deferred.reject(e);
}
return deferred.promise;
</code></pre>

<p>}
<code>``
</code>readFile()<code>gets a file blob (the output of</code><input type="file"><code>field) and uses &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank"&gt;FileReader&lt;/a&gt; to read it's content. Before reading the data and returning a promise,</code>readFile()<code>assigned</code>onload<code>and</code>onerror<code>callbacks that resolve and reject the deferred accordingly with the result. Notice that I decided to wrap</code>reader.readAsDataURL(fileBlob);<code>with</code>try {} catch() {}` block in order to handle run time exceptions. In case of an exception, the deferred is rejected.</p>

<h3>Function that gets file content and uploads it to files storage</h3>

<p>```javascript uploadFile()
function uploadFile(fileData) {</p>

<pre><code>var jQueryPromise = $.ajax({
    method: 'POST',
    url: '&lt;endpoint for our files storage upload action&gt;',
    data: fileData
});

return $q.when(jQueryPromise);
</code></pre>

<p>}
<code>``
Since everyone knows jQuery, I decided to use &lt;a href="#" target="_blank"&gt;</code>$.ajax()<code>&lt;/a&gt; in</code>uploadFile()<code>.</code>$.ajax()<code>returns a promise, which is actually what we need. But, this promise is a jQuery's promise implementation and not</code>$q<code>. Fortunately, here we can use</code>$q.when(value)<code>method, so</code>uploadFile()` uses it and returns a promise.</p>

<h3>Function that reserves a username and returns the reservation id</h3>

<p>```javascript reserveUsername()
function reserveUsername(username) {</p>

<pre><code>return $http.post('&lt;endpoint for username reservation action&gt;', {
    username: username
}).$promise;
</code></pre>

<p>}
<code>``
Here I used &lt;a href="#" target="_blank"&gt;</code>$http<code>&lt;/a&gt; service of AngularJS.</code>$http.post()<code>returns an object that contains a reference to a promise which indicates the post status. This promise is created by</code>$q<code>service inside</code>$http.post()` and this will be the return value.</p>

<p>Now that we have all the methods needed for registration, let's wrap them in a service called <code>appService</code> (you can see the complete <code>app-service.js</code> at the end of this tutorial).</p>

<h3>Application Controller</h3>

<p>Our application controller is pretty simple. It uses <code>$scope</code>, <code>$q</code> and <code>appCervice</code> which are injected in the controller definition. The controller also contains several methods for handling the data (at the end of this tutorial you can find the full source code of this controller).</p>

<h3>Longitude and Latitude</h3>

<p>I don't want the user to be able to enter values for longitude and latitude, the only way to set values on those fields is by getting the geolocation from the device. Here is a markup of two input elements, they are both bound to model and have a readonly attribute.
```html longitude the latitude inputs</p>

<div>
    Longitude
    <input type="text" readonly="readonly" ng-model="coords.longitude" />
</div>


<div>
    Latitude
    <input type="text" readonly="readonly" ng-model="coords.latitude" />
</div>


<p><code>
In the controller, all we have to do is to call `getGeolocationCoordinates()` and set the coordinates data when we get the result:
</code>javascript handling geolocation
appService.getGeolocationCoordinates()</p>

<pre><code>.then(function setCoords(coordsData) {
    $scope.coords = coordsData;
});
</code></pre>

<p>```</p>

<h3>User name</h3>

<p>Here is the markup for user name input. I also added error support by showing the error message and adding an <code>error</code> class in case of an error. Whenever the username input changes, <code>$scope.reserveUsername()</code> is called.
```html user name input</p>

<div ng-class="{ error: usernameError }">
    User Name
    <div>
        <input type="text" ng-model="username" ng-change="reserveUsername()" />
        <div ng-bind="usernameError"></div>
    </div>
</div>


<p><code>
`$scope.reserveUsername()` should use `appService` to reserve the new username, set username reservation data upon success and set an error upon failure.
</code>javascript handling user name
var reservationPromise = $q.reject('No username reservation had made');
$scope.reserveUsername = function() {</p>

<pre><code>var newUsername = $scope.username;
reservationPromise = appService.reserveUsername(newUsername)
    .then(function setUsernameReservation() {
        $scope.reservation = reservation;
    })
    .catch(function setUsernameError() {
        $scope.usernameError = error;
        return $q.reject($scope.usernameError);
    });
</code></pre>

<p>}
<code>``
First,</code>reservationPromise<code>is initialized with a rejected promise to handle a case where no reservation will be made.   
When</code>$scope.reserveUsername()<code>happened, a backend reservation occurs. On success,</code>setUsernameReservation()<code>doesn't return a promise and</code>reservationPromise<code>is resolved (values chaining causes the resulted promise to de resolved). On failure,</code>setUsernameError()<code>returns a rejected promise and so</code>reservationPromise` is rejected with an error message (promises chaining causes the resulted promise to be resolved or rejected according to the chained promise).</p>

<h3>User Photo</h3>

<p>The user photo field contains several components: the file input, a placeholder for the selected photo url, a placeholder for the selected image and a placeholder for an error message. I also used here a directive I wrote, named <code>filePathChanged</code>, that triggers a function whenever the user selects a file. You can see the code of the directive down this page.
```html user photo input</p>

<div ng-class="{ error: photoError }">
    Select Photo
    <input type="file" file-path-changed="fileSelected(files)">
    <span ng-bind="photoError"></span>
    <span ng-if="photoUrl" ng-bind="photoUrl"></span>
    <img ng-if="photoData" ng-src="" />
</div>


<p><code>
Let's see the implementation of `$scope.fileSelected(files)`.   
</code>javascript handling user image
var photoPromise = $q.reject('No user photo selected');
$scope.fileSelected = function(files) {</p>

<pre><code>if (files &amp;&amp; files.length &gt; 0) {
    var filePath = files[0];

    photoPromise = appService.readFile(filePath)
        .then(function setPhotoData(photoData) {
            $scope.photoData = photoData;
            return photoData;
        })
        .then(appService.uploadFile)
        .then(function setPhotoUrl(photoUrl) {
            $scope.photoUrl = photoUrl;
        })
        .catch(function setPhotoError(error) {
            $scope.photoError = 'An error has occurred: ' + error;
            return $q.reject($scope.photoError);
        });
}
</code></pre>

<p>};
<code>``
This code is simple. First we verify that a file is supplied. Next we read the file using</code>appService.readFile()` and set the photo data in a model. Then we upload the file data, get a url for the photo and set the photo url in a model. In case of any error we set the error message in a model and chain rejected promise.</p>

<h3>Registration</h3>

<p>Our last step is the registration button. We have to create a function that collects the longitude and latitude, the selected photo url and the reservation id of the chosen username. In any case of an error with the username reservation or the photo handling, this function has to reflect an error message. Remember, the longitude and latitude are not mandatory so if they are not available at the time of the registration - it will not stop the process.
```javascript register() method
$scope.register = function() {</p>

<pre><code>$q.all([
    reservationPromise,
    photoPromise
]).then(function doRegistrationCall() {
    var longitude = $scope.data.coords &amp;&amp; $scope.data.coords.longitude;
    var latitude = $scope.data.coords &amp;&amp; $scope.data.coords.latitude;
    var reservationId = $scope.data.reservation.token;
    var photoUrl = $scope.data.photoUrl;
    doRegistration(longitude, latitude, reservationId, photoUrl);
}, function setSubmitError(error) {
    $scope.submitError = error;
});
</code></pre>

<p>};
<code>``
Here we used</code>$q.all()<code>because we want to perform an operation after username reservation and photo handling are both done. In case of any rejection we mark that the registration failed by assigning</code>submitError<code>model. In this example,</code>doRegistration()` is a method that does the registration call to the backend.</p>

<p>That's all! our registration process is now complete. <br/>
Here is the full source of our small application.</p>

<h3>app-service.js</h3>

<p>```javascript app-service.js
window.module.factory('appService', ['jquery', '$http', '$q', function($, $http, $q) {</p>

<pre><code>function getGeolocationCoordinates() {
    var deferred = $q.defer();
    navigator.geolocation.getCurrentPosition(
        function(position) { deferred.resolve(position.coords); },
        function(error) { deferred.resolve(null); }
    );
    return deferred.promise;
}

function readFile(fileBlob) {
    var deferred = $q.defer();
    var reader = new FileReader();
    reader.onload = function () { deferred.resolve(reader.result); };
    reader.onerror = function () { deferred.reject(); };
    try {
        reader.readAsDataURL(fileBlob);
    } catch (e) {
        deferred.reject(e);
    }
    return deferred.promise;
}

function uploadFile(fileData) {
    // var jQueryPromise = $.ajax({
    //     method: 'POST',
    //     url: '&lt;endpoint for our files storage upload action&gt;',
    //     data: fileData
    // });

    var deferred = $.Deferred();
    setTimeout(function() {
        deferred.resolve('www.myimage.com/123');
    }, 200);

    var jQueryPromise = deferred.promise();

    return $q.when(jQueryPromise);
}

var reserveCount = 0;
function reserveUsername(username) {
    // return $http.post('&lt;endpoint for username reservation action&gt;', {
    //     username: username
    // }).$promise;
    var deferred = $q.defer();
    setTimeout(function() {
        if (reserveCount &gt; 0 &amp;&amp; reserveCount % 3 === 0) {
            deferred.reject('error reserving "' + username + '"');
        } else {
            var token = 'token' + reserveCount;
            deferred.resolve({
                token: token,
                username: username
            });
        }
        reserveCount ++;
    }, 300);

    return deferred.promise;
}

return {
    getGeolocationCoordinates: getGeolocationCoordinates,
    readFile: readFile,
    uploadFile: uploadFile,
    reserveUsername: reserveUsername
};
</code></pre>

<p>}]);
<code>``
Note: in order to mimic</code>uploadFile()<code>and</code>reserveUsername()` without implementing a backend, I've created a custom code that sometimes is resolved and sometimes is rejected. <br/>
Now we can proceed with the controller implementation.</p>

<h3>app-controller.js</h3>

<p>```javascript app-controller.js
window.module.controller('appController', ['$scope', '$q', 'appService', function($scope, $q, appService) {</p>

<pre><code>$scope.data = { errors: { } };
function setCoords(coordsData) {
    $scope.data.coords = coordsData;
}
function setPhotoData(photoData) {
    return $scope.data.photoData = photoData;
}
function setPhotoUrl(photoUrl) {
    return $scope.data.photoUrl = photoUrl;
}
function clearPhotoError() {
    delete $scope.data.errors.photo;
}
function setPhotoError(error) {
    $scope.data.errors.photo = 'An error has occurred: ' + error;
    return $q.reject($scope.data.errors.photo);
}
function clearUsernameError() {
    delete $scope.data.errors.username;
}
function setUsernameError(error) {
    $scope.data.errors.username = error;
    return $q.reject($scope.data.errors.username);
}
function setUsernameReservation(reservation) {
    $scope.data.reservation = reservation;
}

function setSubmitError(error) {
    $scope.data.errors.submit = error;
}
function clearSubmitError() {
    delete $scope.data.errors.submit;
}

function doRegistration(longitude, latitude, reservationId, photoUrl) {
    $scope.data.success = true;
    $scope.storedJSON = JSON.stringify({
        longitude: longitude,
        latitude: latitude,
        reservationId: reservationId,
        photoUrl: photoUrl
    });
}

appService.getGeolocationCoordinates()
    .then(setCoords);

var photoPromise = $q.reject('No user photo selected');
$scope.fileSelected = function(files) {
    if (files &amp;&amp; files.length &gt; 0) {
        var filePath = files[0];

        clearPhotoError();
        photoPromise = appService.readFile(filePath)
            .then(setPhotoData)
            .then(appService.uploadFile)
            .then(setPhotoUrl)
            .catch(setPhotoError);
    }
};

var reservationPromise = $q.reject('No username reservation had made');
$scope.reserveUsername = function() {
    var newUsername = $scope.data.username;
    clearUsernameError();
    reservationPromise = appService.reserveUsername(newUsername)
        .then(setUsernameReservation)
        .catch(setUsernameError);
}

$scope.register = function() {
    $q.all([
        reservationPromise,
        photoPromise
    ]).then(function() {
        var longitude = $scope.data.coords &amp;&amp; $scope.data.coords.longitude;
        var latitude = $scope.data.coords &amp;&amp; $scope.data.coords.latitude;
        var reservationId = $scope.data.reservation.token;
        var photoUrl = $scope.data.photoUrl;
        clearSubmitError();
        doRegistration(longitude, latitude, reservationId, photoUrl);
    }, function(error) {
        setSubmitError(error);
    });
};
</code></pre>

<p>}]);
```</p>

<h3>index.html</h3>

<p>```html index.html
&lt;!doctype html>
<html>
<head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
&lt;title&gt;&lt;/title&gt;

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    window.angular || document.write('&lt;script src="http://webdeveasy.com/scripts/libs/jquery.js"&gt;&lt;\/script&gt;');
&lt;/script&gt;

&lt;script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.2.14/angular.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    window.angular || document.write('&lt;script src="http://webdeveasy.com/scripts/libs/angular.js"&gt;&lt;\/script&gt;');
&lt;/script&gt;

&lt;link rel="stylesheet" href="http://webdeveasy.com/style/semantic.css" /&gt;
&lt;link rel="stylesheet" href="http://webdeveasy.com/style/app.css" /&gt;
</code></pre>

<p></head>
<body ng-app="demo-app"></p>

<pre><code>&lt;form class="ui form segment" ng-controller="appController"&gt;
    &lt;div class="two fields"&gt;
        &lt;div class="field"&gt;
            &lt;label for="longitude"&gt;Longitude&lt;/label&gt;
            &lt;input id="longitude" type="text" readonly="readonly" ng-model="data.coords.longitude" placeholder="No Longitude" /&gt;
        &lt;/div&gt;
        &lt;div class="field"&gt;
            &lt;label for="latitude"&gt;Latitude&lt;/label&gt;
            &lt;input id="latitude" type="text" readonly="readonly" ng-model="data.coords.latitude" placeholder="No Latitude" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="field username" ng-class="{ error: data.errors.username }"&gt;
        &lt;label for="username"&gt;User Name&lt;/label&gt;
        &lt;div class="ui labeled icon input"&gt;
            &lt;input id="username" type="text" ng-model="data.username" ng-change="reserveUsername()" placeholder="User Name" /&gt;
            &lt;div class="ui red label pointing above" ng-bind="data.errors.username"&gt;&lt;/div&gt;
            &lt;i class="circular ban circle icon"&gt;&lt;/i&gt;
            &lt;i class="circular checkmark icon" ng-if="data.reservation"&gt;&lt;/i&gt;
            &lt;div class="ui corner label"&gt;
                &lt;i class="icon asterisk"&gt;&lt;/i&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="inline field user-photo" ng-class="{ error: data.errors.photo }"&gt;
        &lt;label for="file" class="ui icon button"&gt;
            &lt;i class="file icon"&gt;&lt;/i&gt;
            Select Photo
        &lt;/label&gt;
        &lt;input type="file" id="file" file-path-changed="fileSelected(files)"&gt;
        &lt;span class="ui red label" ng-bind="data.errors.photo"&gt;&lt;/span&gt;
        &lt;span class="ui green label" ng-if="data.photoUrl" ng-bind="data.photoUrl"&gt;&lt;/span&gt;
        &lt;div class="ui segment" ng-if="data.photoData"&gt;
            &lt;img class="rounded ui image" ng-src="" /&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="field"&gt;
        &lt;div class="ui blue submit button" ng-click="register()"&gt;Register&lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="field"&gt;
        &lt;span class="ui red label" ng-if="data.errors.submit" ng-bind="data.errors.submit"&gt;&lt;/span&gt;
        &lt;span class="ui green label" ng-if="data.success"&gt;
            Registration Seccess with ,
            ,
            username = , photo url = 
        &lt;/span&gt;
    &lt;/div&gt;
&lt;/form&gt;

&lt;script type="text/javascript" src="scripts/module.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="scripts/directives.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="scripts/app-service.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="scripts/app-controller.js"&gt;&lt;/script&gt;
</code></pre>

<p></body>
</html>
```
Here I used <a href="http://semantic-ui.com/" target="_blank">a nice CSS framework</a> named <i>Semantic UI</i> in order to produce a better looking UI. Therefore this markup contains many classes and other elements.</p>

<h3>directives.js</h3>

<p>We only have one directive named <code>filePathChanged</code>.
```javascript directives.js
window.module.directive('filePathChanged', function() {</p>

<pre><code>return {
    restrict: 'A',
    scope: {
        filePathChanged: '&amp;'
    },
    link: function (scope, element, attrs) {
        element.bind('change', function() {
            scope.filePathChanged({ files: element.prop('files') });
        });
    }
};
</code></pre>

<p>});
```</p>

<h2>Summary</h2>

<p>After reading this article you should know by now that working with callbacks might make a hard life especially when synchronization is needed (parallel and sequentially executing). You were introduced with the deferrers and promises solution and saw how to use it. Through this article you saw explanations and examples of important promises methods and learned about promises chaining. At the end you got a practical tutorial. Here is a short list to summarize the methods mentioned in this article:</p>

<ul>
    <li><code>var deferred = $q.defer();</code> - creates a new deferred</li>
    <li><code>deferred.resolve(value);</code> - resolves a deferred with a value</li>
    <li><code>deferred.reject(reason);</code> - rejects a deferred with a reason</li>
    <li><code>var promise = deferred.promise;</code> - gets a promise from deferred</li>
    <li><code>promise.then(success, failure);</code> - assigns callbacks for success (resolve) and failure (reject)</li>
    <li><code>promise.catch(failure);</code> - assigns failure callback (equals to <code>promise.then(null, failure)</code>)</li>
    <li><code>promise.finally(always);</code> - assign a callback to be called both on success or failure</li>
    <li><code>var promise = $q.reject(reason);</code> - returns rejected promise with a reason</li>
    <li><code>var promise = $q.when(valueOrPromise);</code> - wraps value or other implementation of thenable promise with AngularJS promise</li>
    <li><code>var promise = $q.all(promisesArr);</code> - returns a promise that will be resolved only when all promises in `promisesArr` are resolved</li>
</ul>


<p>Here are two additional links:</p>

<ul>
    <li><a target="_blank" href="http://webdeveasy.com/code/javascript-promises-and-angularjs-q-service/index.html">The tutorial application in action</a></li>
    <li><a target="_blank" href="https://github.com/naorye/angulajs-q-service-tutorial">The tutorial source on GitHub</a></li>
    <li><a href="https://github.com/naorye/angulajs-q-service-tutorial/archive/master.zip">The tutorial source zip file</a></li>
</ul>


<p>I really hope you liked this article!
Good luck,
NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Back Button Behavior on a Page With an iframe]]></title>
    <link href="http://webdeveasy.com/back-button-behavior-on-a-page-with-an-iframe/"/>
    <updated>2014-05-29T01:45:45+03:00</updated>
    <id>http://webdeveasy.com/back-button-behavior-on-a-page-with-an-iframe</id>
    <content type="html"><![CDATA[<p>I am developing a widget for websites. This widget lays inside an iframe in a website's page. One of my users (which is a site owner) complained about a weird behavior of my widget. On pages where the widget was implemented, the browser's back button didn't work properly. Instead of navigating the user to the previous page on the website, the back button navigated the user to the previous page inside the iframe.</p>

<!-- more -->


<p>Let me show you an example. This <a target="_blank" href="http://webdeveasy.com/code/back-button-behavior-on-a-page-with-an-iframe/problem/page1.html">demo page</a> includes two pages. The first page contains nothing but a link to the second page. When clicking on the link, we are redirected to the second page that contains an iframe. At this point, looking on the browser's history will show us only the first page as expected:</p>

<p><img src="http://webdeveasy.com/code/back-button-behavior-on-a-page-with-an-iframe/problem/images/page2.png" /></p>

<p>In order to demonstrate navigation inside an iframe, the iframe in the second page contains a page with an anchor. This anchor refers to a different page. A click on the anchor causes navigation inside the iframe, but also adds a new history entry of the second page:</p>

<p><img src="http://webdeveasy.com/code/back-button-behavior-on-a-page-with-an-iframe/problem/images/iframe2.png" /></p>

<p>Pressing back will not return us back to the first page. Instead, it will change the iframe's page and this is not the desired behavior. <br/>
What we really want is the iframe's navigation not to interfere the browser's navigation. Pressing the back button should take us back to the first page and not to the previous iframe's page.</p>

<p><strong><em>It appears that any location change in the iframe is stored in the browser's history.</em></strong></p>

<p>Once the problem is understood, the solution is pretty simple. Whenever the user navigates inside the iframe, we don't want to add a new entry to the history. In order to do that, I'd like to explain a bit about anchors.</p>

<h2>How anchors work?</h2>

<p>When an anchor is clicked, it navigates to the new page and the new location is added to the browser's hitory. But, if the url is the same as the current url, no history entry is added and the anchor only performs a page refresh. It is easy to verify what I am saying here by creating a page that contains a link to itself. Clicking on this anchor only refreshes the page and no history entry is added.</p>

<h2>history.replaceState() To The Rescue</h2>

<p>Luckily HTML5 gave us <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history" target="_blank">a great API for controlling the history</a>. <code>window.history</code> exposes useful methods that let us manipulate the contents of the history stack. Among these methods we can find the <code>replaceState()</code> method. <code>history.replaceState()</code> can modify the current history entry and associate it with the current document. <br/>
Assuming we have the following anchor inside an iframe's page: <code>&lt;a href="iframe2.html"&gt;iframe page 2&lt;/a&gt;</code>. Clicking on it redirects us to <code>page2.html</code> and adds a new history entry for that page. If the current location, prior to the anchor's action, is the same as the anchor's url, then no new history entry will be added. <br/>
Let's manipulate the history and set the current location to the anchor's url before the anchor performs it's action:
```javascript Prevent anchors to add history entry</p>

<pre><code>var anchors = document.getElementsByTagName('a');
for (var i = 0; i &lt; anchors.length; i++) {
    var anchor = anchors[i];
    anchor.addEventListener('click', function(event) {
        history.replaceState(null, null, anchor.href);
    }, false);
}
</code></pre>

<p>```
This script runs through all the page's anchors and attaches a click event. Whenever the user clicks on an anchor, the current location is replaced with the anchor's href. And here we prevented from another history entry to be added. <br/>
Keep in mind that this script has to run at the end of the page, after the DOM has loaded. <br/>
Here You can see the <a target="_blank" href="http://webdeveasy.com/code/back-button-behavior-on-a-page-with-an-iframe/solution/page1.html">solution</a>. Navigating inside the iframe doesn't create history entry:</p>

<p><img src="http://webdeveasy.com/code/back-button-behavior-on-a-page-with-an-iframe/solution/images/iframe2.png" /></p>

<p>I spent a lot of time trying to understand the behavior of anchors and history and finding a solution for the back button issue. I hope you'll find this explanation interesting and useful. <br/>
Thanks for reading,
NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Interceptors in AngularJS and Useful Examples]]></title>
    <link href="http://webdeveasy.com/interceptors-in-angularjs-and-useful-examples/"/>
    <updated>2014-03-08T22:44:14+02:00</updated>
    <id>http://webdeveasy.com/interceptors-in-angularjs-and-useful-examples</id>
    <content type="html"><![CDATA[<p>The <code>$http</code> service of AngularJS allows us to communicate with a backend and make HTTP requests. There are cases where we want to capture every request and manipulate it before sending it to the server. Other times we would like to capture the response and process it before completing the call. Global http error handling can be also a good example of such need. Interceptors are created exactly for such cases. This article will introduce AngularJS interceptors and will provide some useful examples.</p>

<!-- more -->


<h2>What are Interceptors?</h2>

<p>The <code>$httpProvider</code> provider contains an array of interceptors. An interceptor is simply a regular service factory that is registered to that array. This is how we create an interceptor:
```javascript Interceptor declaration
module.factory('myInterceptor', ['$log', function($log) {</p>

<pre><code>$log.debug('$log is here to show you that this is a regular factory with injection');

var myInterceptor = {
    ....
    ....
    ....
};

return myInterceptor;
</code></pre>

<p>}]);
<code>
And then add it by it's name to `$httpProvider.interceptors` array:
</code> javascript add the interceptor to $httpProvider.interceptors
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('myInterceptor');
</code></pre>

<p>}]);
```
Interceptors allow you to:</p>

<ul>
<li><p><strong>Intercept a request by implementing the <code>request</code> function:</strong> This method is called before <code>$http</code> sends the request to the backend, so you can modify the configurations and make other actions. This function receives the request configuration object as a parameter and has to return a configuration object or a promise. Returning an invalid configuration object or promise that will be rejected, will make the <code>$http</code> call to fail.</p></li>
<li><p><strong>Intercept a response by implementing the <code>response</code> function:</strong> This method is called right after <code>$http</code> receives the response from the backend, so you can modify the response and make other actions. This function receives a response object as a parameter and has to return a response object or a promise. The response object includes the request configuration, headers, status and data that returned from the backend. Returning an invalid response object or promise that will be rejected, will make the <code>$http</code> call to fail.</p></li>
<li><p><strong>Intercept request error by implementing the <code>requestError</code> function:</strong> Sometimes a request can't be sent or it is rejected by an interceptor. Request error interceptor captures requests that have been canceled by a previous request interceptor. It can be used in order to recover the request and sometimes undo things that have been set up before a request, like removing overlays and loading indicators, enabling buttons and fields and so on.</p></li>
<li><p><strong>Intercept response error by implementing the <code>responseError</code> function:</strong> Sometimes our backend call fails. Other times it might be rejected by a request interceptor or by a previous response interceptor. In those cases, response error interceptor can help us to recover the backend call.</p></li>
</ul>


<h2>Asynchronous Operations</h2>

<p>Sometimes there is a need to make some asynchronous operations inside the interceptor. Luckily AngularJS allows us to return a promise that will be resolved later. This will defer the request sending in case of request interceptor and will defer the response resolving in case of response interceptor.
```javascript Make asynchronous operations in request interceptor
module.factory('myInterceptor', ['$q', 'someAsyncService', function($q, someAsyncService) {</p>

<pre><code>var requestInterceptor = {
    request: function(config) {
        var deferred = $q.defer();
        someAsyncService.doAsyncOperation().then(function() {
            // Asynchronous operation succeeded, modify config accordingly
            ...
            deferred.resolve(config);
        }, function() {
            // Asynchronous operation failed, modify config accordingly
            ...
            deferred.resolve(config);
        });
        return deferred.promise;
    }
};

return requestInterceptor;
</code></pre>

<p>}]);
<code>
In this example, the request interceptor makes an asynchronous operation and updates the config according to the results. Then it continues with the modified config. If `deferred` is rejected, the http request will fail.   
The same applies for response interceptor:
</code>javascript Make asynchronous operations in response interceptor
module.factory('myInterceptor', ['$q', 'someAsyncService', function($q, someAsyncService) {</p>

<pre><code>var responseInterceptor = {
    response: function(response) {
        var deferred = $q.defer();
        someAsyncService.doAsyncOperation().then(function() {
            // Asynchronous operation succeeded, modify response accordingly
            ...
            deferred.resolve(response);
        }, function() {
            // Asynchronous operation failed, modify response accordingly
            ...
            deferred.resolve(response);
        });
        return deferred.promise;
    }
};

return responseInterceptor;
</code></pre>

<p>}]);
<code>``
Only when</code>deferred<code>is resolved, the request will succeed. If</code>deferred` is rejected, the request will fail.</p>

<h2>Examples</h2>

<p>In this section I'll provide some examples to AngularJS Interceptors in order to give a good understanding of how to use them and how they can help you. Keep in mind that the solutions I provide here are not necessarily the best or the most accurate solutions.</p>

<h3>Session Injector (request interceptor)</h3>

<p>There are two ways of implementing server side authentication. The first one is to use the traditional Cookie-Based Authentication that uses server side cookies to authenticate the user on each request. The other approach is Token-Based Authentication. When the user logs in, he gets <code>sessionToken</code> from the backend. This <code>sessionToken</code> identifies the user in the server and is sent to the server on each request. <br/>
The following <code>sessionInjector</code> adds <code>x-session-token</code> header to each intercepted request (in case the current user is logged in):
```javascript Session Injector
module.factory('sessionInjector', ['SessionService', function(SessionService) {</p>

<pre><code>var sessionInjector = {
    request: function(config) {
        if (!SessionService.isAnonymus) {
            config.headers['x-session-token'] = SessionService.token;
        }
        return config;
    }
};
return sessionInjector;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('sessionInjector');
</code></pre>

<p>}]);
<code>
And now creating a get request:
</code>javascript
$http.get('https://api.github.com/users/naorye/repos');
<code>
The configuration object before intercepted by `sessionInjector`:
</code>javascript
{</p>

<pre><code>"transformRequest": [
    null
],
"transformResponse": [
    null
],
"method": "GET",
"url": "https://api.github.com/users/naorye/repos",
"headers": {
    "Accept": "application/json, text/plain, */*"
}
</code></pre>

<p>}
<code>
The configuration object after intercepted by `sessionInjector`:
</code>javascript
{</p>

<pre><code>"transformRequest": [
    null
],
"transformResponse": [
    null
],
"method": "GET",
"url": "https://api.github.com/users/naorye/repos",
"headers": {
    "Accept": "application/json, text/plain, */*",
    "x-session-token": 415954427904
}
</code></pre>

<p>}
```</p>

<h3>Timestamp Marker (request and response interceptors)</h3>

<p>Let's measure the time it takes to get a backend response using interceptors. It is done by adding a timestamp for each request and response:
```javascript Timestamp Marker
module.factory('timestampMarker', [function() {</p>

<pre><code>var timestampMarker = {
    request: function(config) {
        config.requestTimestamp = new Date().getTime();
        return config;
    },
    response: function(response) {
        response.config.responseTimestamp = new Date().getTime();
        return response;
    }
};
return timestampMarker;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('timestampMarker');
</code></pre>

<p>}]);
<code>
And now we can do:
</code>javascript
$http.get('https://api.github.com/users/naorye/repos').then(function(response) {</p>

<pre><code>var time = response.config.responseTimestamp - response.config.requestTimestamp;
console.log('The request took ' + (time / 1000) + ' seconds.');
</code></pre>

<p>});
```
Here you can find an <a href="http://webdeveasy.com/code/interceptors-in-angularjs-and-useful-examples/timestamp-marker.html" target="_blank">example for the Timestamp Marker</a>.</p>

<h3>Request Recover (request error interceptor)</h3>

<p>In order to demonstrate a request error interceptor we have to simulate a situation where a previous interceptor rejects the request. Our request error interceptor will get the rejection reason and will recover the request. <br/>
Let's create two interceptors: <code>requestRejector</code> and <code>requestRecoverer</code>. <br/>
```javascript Request Recoverer
module.factory('requestRejector', ['$q', function($q) {</p>

<pre><code>var requestRejector = {
    request: function(config) {
        return $q.reject('requestRejector');
    }
};
return requestRejector;
</code></pre>

<p>}]);
module.factory('requestRecoverer', ['$q', function($q) {</p>

<pre><code>var requestRecoverer = {
    requestError: function(rejectReason) {
        if (rejectReason === 'requestRejector') {
            // Recover the request
            return {
                transformRequest: [],
                transformResponse: [],
                method: 'GET',
                url: 'https://api.github.com/users/naorye/repos',
                headers: {
                    Accept: 'application/json, text/plain, */*'
                }
            };
        } else {
            return $q.reject(rejectReason);
        }
    }
};
return requestRecoverer;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('requestRejector');
// Removing 'requestRecoverer' will result to failed request
$httpProvider.interceptors.push('requestRecoverer'); 
</code></pre>

<p>}]);
<code>
And now, if we do the following, we will get the log `success` even though `requestRejector` rejected the request:
</code>javascript
$http.get('https://api.github.com/users/naorye/repos').then(function() {</p>

<pre><code>console.log('success');
</code></pre>

<p>}, function(rejectReason) {</p>

<pre><code>console.log('failure');
</code></pre>

<p>});
```
Here you can find an <a href="http://webdeveasy.com/code/interceptors-in-angularjs-and-useful-examples/request-recover.html" target="_blank">example for the Request Recover</a>.</p>

<h3>Session Recoverer (response error interceptor)</h3>

<p>There are times, in our single page application, where the session gets lost. Such situation might happen due to session expiration or a server error. Let's create an interceptor that will recover the session and resend the original request again automatically (for situations where the session expired). <br/>
For the example purposes, let's assume that the http status code for session expiration is 419.
```javascript Session Recoverer
module.factory('sessionRecoverer', ['$q', '$injector', function($q, $injector) {</p>

<pre><code>var sessionRecoverer = {
    responseError: function(response) {
        // Session has expired
        if (response.status == 419){
            var SessionService = $injector.get('SessionService');
            var $http = $injector.get('$http');
            var deferred = $q.defer();

            // Create a new session (recover the session)
            // We use login method that logs the user in using the current credentials and
            // returns a promise
            SessionService.login().then(deferred.resolve, deferred.reject);

            // When the session recovered, make the same backend call again and chain the request
            return deferred.promise.then(function() {
                return $http(response.config);
            });
        }
        return $q.reject(response);
    }
};
return sessionRecoverer;
</code></pre>

<p>}]);
module.config(['$httpProvider', function($httpProvider) {</p>

<pre><code>$httpProvider.interceptors.push('sessionRecoverer');
</code></pre>

<p>}]);
<code>``
This way, whenever a backend call fails due to session expiration,</code>sessionRecoverer` creates a new session and performs the backend call again.</p>

<h2>Summary</h2>

<p>In this article I explained about AngularJS interceptors. I presented <code>request</code>, <code>response</code>, <code>requestError</code> and <code>responseError</code> interceptors and described how and when to use them. I also provided real world useful examples that can help you in your development.</p>

<p>I hope you enjoyed reading this article as much as I enjoyed writing it! <br/>
Good Luck! <br/>
NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service Providers in AngularJS and Logger Implementation]]></title>
    <link href="http://webdeveasy.com/service-providers-in-angularjs-and-logger-implementation/"/>
    <updated>2014-02-08T16:49:33+02:00</updated>
    <id>http://webdeveasy.com/service-providers-in-angularjs-and-logger-implementation</id>
    <content type="html"><![CDATA[<p>In this article I'll explain what a provider is and what is the difference between a provider and other services declaration in AngularJS. Through this article I'll also create a tidy Logger for your AngularJS application.</p>

<!-- more -->


<h2>What is wrong with $log?</h2>

<p>Nothing! Really, $log is doing it's work. It is a simple service for logging, including a default implementation that writes messages into the browser's console. And that's it. But when talking about logging, I'd like a service that will print my messages nicely, something like a timestamp and maybe a hint about where the message was created. I would also like to turn off all the messages during application configuration when running on production, and maybe expose a way to turn it on. I know $logProvider has the <code>debugEnabled(flag)</code> method, but I would like to turn off all the other kinds of messages (like <code>info()</code> and <code>error()</code>) and not only debug. Later on I may want to add colors to my messages and maybe aggregate all the <code>error()</code> messages and send them somehow to me. This is why I was looking to create a new logging mechanism. <br/>
While thinking about a way of implementation, I considered using a <a href="http://docs.angularjs.org/api/AUTO.$provide#decorator" target="_blank">service decorator</a> but then realized that I might want more than modifying the behavior of $log, like add or remove methods, or change the way $log's methods work. Eventually I decided to use a <a href="http://docs.angularjs.org/api/AUTO.$provide#methods_provider" target="_blank">service provider</a>.</p>

<h2>A little about AngularJS services</h2>

<p>This section might be a little confusing, but it is really important to understand. When we call <code>module.provider()</code>, we are actually calling the <code>provider()</code> method of the <code>$provide</code> service. <code>$provide.provider()</code> is exposed on <code>angular.Module</code>. The same is for <code>module.service()</code> and <code>module.factory()</code>, they are methods of <code>$provide</code> service that are exposed on <code>angular.Module</code>. Therefore the following blocks are the same thing:
<code>javascript Calling directly to module.provider(), module.service() and module.factory()
module.provider('providerName', function() { ... });
module.service('serviceName', function() { ... });
module.factory('factoryName', function() { ... });
</code>
```
module.config(['$provide', function($provide) {</p>

<pre><code>$provide.provider('providerName', function() { ... });
</code></pre>

<p>});
module.config(['$provide', function($provide) {</p>

<pre><code>$provide.service('serviceName', function() { ... });
</code></pre>

<p>});
module.config(['$provide', function($provide) {</p>

<pre><code>$provide.factory('factoryName', function() { ... });
</code></pre>

<p>});
<code>
More than that, `$provide.service()` and `$provide.factory()` are actually an easy way to use `$provide.provider()`:
</code> javascript $provide.service() and $provide.factory() are actually $provide.provider()
$provide.service('serviceName', function() {</p>

<pre><code>this.name = 'The Catcher in the Rye';
this.author = 'J. D. Salinger';
</code></pre>

<p>});
// Equals to
$provide.provider('serviceName', function() {</p>

<pre><code>this.$get = function($injector) {
    return $injector.instantiate(function() {
        this.name = 'The Catcher in the Rye';
        this.author = 'J. D. Salinger';
    });
};
</code></pre>

<p>});</p>

<p>$provide.factory('factoryName', function() {</p>

<pre><code>return { name: 'The Catcher in the Rye', author: 'J. D. Salinger' };
</code></pre>

<p>});
// Equals to
$provide.provider('serviceName', function() {</p>

<pre><code>this.$get = function($injector) {
    return $injector.invoke(function() {
        return { name: 'The Catcher in the Rye', author: 'J. D. Salinger' };
    });
};
</code></pre>

<p>});
<code>``
As we all can see, AngularJS only knows service provider (</code>$provide.provider()`) and all other ways of creating services are derived.</p>

<h2>What service provider gives?</h2>

<p>Besides of creating the service, service provider allows to configure the service on <code>module.config()</code> block. Look on the following <code>appColor</code> example service that is defined by a service provider:
<code>`` javascript Sample</code>appColor` service provider
$provide.provider('appColor', function() {</p>

<pre><code>var color = 'Green';
this.setColor = function(newColor) {
    color = newColor;
};
this.$get = function() {
    return color;
};
</code></pre>

<p>});
<code>
Whenever we ask from Angular to inject `appColor`, we get the `color` variable that returned from the `$get` method. But on `module.config()` blocks we can ask for `appColorProvider` which exposes the provider and all it's methods and attributes. This let us configure the service before other code consumes it:
</code> javascript <code>appColor</code> configuration and usage
module.config(['appColorProvider', function(appColorProvider) {</p>

<pre><code>appColorProvider.setColor('Blue');
</code></pre>

<p>});
...
...
module.run(['appColor', function(appColor) {</p>

<pre><code>// Will log: 'Application color is Blue'
console.log('Application color is ' + appColor);
</code></pre>

<p>});
```
As you can see, service provider gave us access to the "provider" part, where we can set methods or variables and which can be accessed during configuration only. And this is what I was looking for when thinking about creating my Logger.</p>

<h2>Creating the Logger!</h2>

<p>I want to create a Logger service that will print my messages in the following formats (according to the supplied arguments):  <br/>
<code>&lt;timestamp&gt; - &lt;context&gt;::&lt;method name&gt;('&lt;message&gt;')</code>
<code>&lt;timestamp&gt; - &lt;context&gt;: &lt;message&gt;</code></p>

<p>Before integrating with Angular, let's create a Logger class that uses $log. First we will create a Logger constructor and a static helper method that will create new instances of Logger.
``` javascript Logger construction
var Logger = function(context) {</p>

<pre><code>this.context = context;
</code></pre>

<p>};
Logger.getInstance = function(context) {</p>

<pre><code>return new Logger(context);
</code></pre>

<p>};
<code>
The constructor gets a context as a parameter.   
I want it to be easy to interpolate variables into the message string. Therefore, let's take Douglas Crockford's &lt;a href="http://javascript.crockford.com/remedial.html" target="_blank"&gt;supplant implementation&lt;/a&gt; and put it as a helper in Logger:
</code> javascript supplant support
Logger.supplant = function(str, o) {</p>

<pre><code>return str.replace(
        /\{([^{}]*)\}/g,
        function (a, b) {
            var r = o[b];
            return typeof r === 'string' || typeof r === 'number' ? r : a;
        }
    );
</code></pre>

<p>};
<code>
Now it is easy to add a method that returns a formatted timestamp:
</code> javascript formatted timestamp on message
Logger.getFormattedTimestamp = function(date) {
   return Logger.supplant('{0}:{1}:{2}:{3}', [</p>

<pre><code>    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
]); 
</code></pre>

<p>};
<code>
Notice that the last two methods are generic methods and you can take them out and put in your `utils` service for example.   
Now we want to write a generic `_log()` method that gets the original method of `$log` (log, info, warn, debug or error) and uses it to print a message according to the given arguments. First I'll show my implementation and then explain:
</code>javascript generic <code>_log()</code> method
Logger.prototype = {</p>

<pre><code>// Supports the following arguments: fnName (optional), message (mandatory), supplantData (optional)
// Length and types of arguments are checked in order to determine the usage
_log: function(originalFn, args) {
    var now  = Logger.getFormattedTimestamp(new Date());
    var message = '', supplantData = [];
    switch (args.length) {
        case 1:
            message = Logger.supplant("{0} - {1}: {2}", [ now, this.context, args[0] ]);
            break;
        case 3:
            supplantData = args[2];
            message = Logger.supplant("{0} - {1}::{2}(\'{3}\')", [ now, this.context, args[0], args[1] ]);
            break;
        case 2:
            if (typeof args[1] === 'string') {
                message = Logger.supplant("{0} - {1}::{2}(\'{3}\')", [ now, this.context, args[0], args[1] ]);
            } else {
                supplantData = args[1];
                message = Logger.supplant("{0} - {1}: {2}", [ now, this.context, args[0] ]);
            }
            break;
    }

    $log[originalFn].call(null, Logger.supplant(message, supplantData));
},
...
</code></pre>

<p>};
<code>``
</code>_log()` method first gets the formatted current date. Then it checks for the arguments length and types and determines which output the user wants to print:</p>

<ol>
<li>If the user supplied one argument, then the argument must be the message itself and <code>_log()</code> will print: <code>&lt;timestamp&gt; - &lt;context&gt;: &lt;message&gt;</code></li>
<li>If the user supplied three arguments, then the first argument is a method name, the second is the message and the third is an object of variables to interpolate with the message. For this, <code>_log()</code> will print: <code>&lt;timestamp&gt; - &lt;context&gt;::&lt;method name&gt;('&lt;message&gt;')</code></li>
<li>If the user provided two arguments, we need to find out whether he supplied a method name or an interpolation object. In order to figure that out, we'll check the type of the last argument. If it is a string, then it has to be the message itself while the first argument is the method name. Otherwise consider the first argument as the message and the second as array of interpolation variables. The output print will be according to this check.</li>
</ol>


<p>At the end, <code>_log()</code> calls the required method on $log with the interpolated message. <br/>
Now the last thing to do is to implement an overrides to <code>log()</code>, <code>info()</code>, <code>warn()</code>, <code>debug()</code> and <code>error()</code>:
```javascript implement $log overrides
Logger.prototype = {</p>

<pre><code>...
log: function() {
    this._log('log', arguments);
},
info: function() {
    this._log('info', arguments);
},
warn: function() {
    this._log('warn', arguments);
},
debug: function() {
    this._log('debug', arguments);
},
error: function() {
    this._log('error', arguments);
}
</code></pre>

<p>};
<code>
Finally we have a Logger! This is how we can use it:
</code> javascript Logger usage example
var logger = Logger.getInstance('Example'); // Name of this file / class / module
logger.log('This is a log'); // Logs: "19:24:1:263 - Example: This is a log"
logger.warn('warn', 'This is a warn'); // Warns: "19:24:1:263 - Example::warn('This is a warn')"
logger.error('This is a {0} error! {1}', [ 'big', 'just kidding' ]); // Shouts: "19:24:1:263 - Example: This is a big error! just kidding"
logger.debug('debug', 'This is a debug for line {0}', [ 8 ]); // Logs: "19:24:1:263 - Example::debug('This is a debug for line 8')"
```
Now we can finally integrate our new Logger with AngularJS service provider!</p>

<h2>Back To AngularJS Service Provider</h2>

<p>I wanted to create Logger provider with the ability of disable all the logs. For that I've created a provider that wraps our Logger implementation and adds a method to LoggerProvider for enable or disable Logger:
``` javascript Logger service provider
module.provider('Logger', [function () {</p>

<pre><code>var isEnabled = true;
this.enabled = function(_isEnabled) {
    isEnabled = !!_isEnabled;
};

// $log injected as a dependency
this.$get = ['$log', function($log) {
    var Logger = ...
    ... // Logger implementation

    return Logger;
}];
</code></pre>

<p>}]);
<code>
The last thing left to do is to change the `_log()` to do nothing if `isEnabled` equals to false:
</code> javascript enable / disable <code>_log()</code>
Logger.prototype = {</p>

<pre><code>_log: function(originalFn, args) {
    if (!isEnabled) {
        return;
    }
    ....
</code></pre>

<p><code>
As you can see, Logger is enabled by default. In order to turn it off we just need to do:
</code>javascript Turn off logger
module.config(['Logger', function(Logger) {</p>

<pre><code>Logger.enabled(false);
</code></pre>

<p>});
```
Thats all!</p>

<h2>Summary</h2>

<p>On this article I discussed the difference between AngularJS factory, service and provider. I showed the similarity and explained that service provider is a base method that all other ways of creating services are derived from. I also explained the options of service provider over other services and the most important thing, created a Logger provider with you!</p>

<p>Here you can find <a href="https://github.com/naorye/angular-ny-logger" target="_blank">Logger GitHub Repository</a> with the source code and a demo.</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS Data Model]]></title>
    <link href="http://webdeveasy.com/angularjs-data-model/"/>
    <updated>2013-11-23T20:51:33+02:00</updated>
    <id>http://webdeveasy.com/angularjs-data-model</id>
    <content type="html"><![CDATA[<p>As we already know, AngularJS doesn't come with an out of the box solution for data modeling. In the most abstract way, AngularJS lets us use JSON data as a model in the controller. As the time passed and my application grew, I realized that this modeling method isn't powerful enough to fit my application's needs. In this article I will present the way I dealt with data modeling in my AngularJS application.</p>

<!-- more -->


<h2>Defining a model for controller</h2>

<p>Let's start with a simple example. I would like to display a book view. This is the controller:
```javascript BookController
app.controller('BookController', ['$scope', function($scope) {</p>

<pre><code>$scope.book = {
    id: 1,
    name: 'Harry Potter',
    author: 'J. K. Rowling',
    stores: [
        { id: 1, name: 'Barnes &amp; Noble', quantity: 3},
        { id: 2, name: 'Waterstones', quantity: 2},
        { id: 3, name: 'Book Depository', quantity: 5}
    ]
};
</code></pre>

<p>}]);
<code>
This controller creates a model of book which can be later used in our template:
</code>html template for displaying a book</p>

<div ng-controller="BookController">
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
</div>


<p><code>
In case we would like to get the book data from a backend api, we can also use $http:
</code>javascript BookController with $http
app.controller('BookController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>var bookId = 1;

$http.get('ourserver/books/' + bookId).success(function(bookData) {
    $scope.book = bookData;
});
</code></pre>

<p>}]);
<code>
Notice that bookData is still a JSON object.
Later on we would like to do something with this data. For example, update the book, delete it or even do other operations that are not dealing with the backend, like generate a book image url according to requested size or determining whether the book is available. Those methods can be declared on our controller:
</code>javascript BookController with several book actions
app.controller('BookController', ['$scope', '$http', function($scope, $http) {</p>

<pre><code>var bookId = 1;

$http.get('ourserver/books/' + bookId).success(function(bookData) {
    $scope.book = bookData;
});

$scope.deleteBook = function() {
    $http.delete('ourserver/books/' + bookId);
};

$scope.updateBook = function() {
    $http.put('ourserver/books/' + bookId, $scope.book);
};

$scope.getBookImageUrl = function(width, height) {
    return 'our/image/service/' + bookId + '/width/height';
};

$scope.isAvailable = function() {
    if (!$scope.book.stores || $scope.book.stores.length === 0) {
        return false;
    }
    return $scope.book.stores.some(function(store) {
        return store.quantity &gt; 0;
    });
};
</code></pre>

<p>}]);
<code>
And later in our template:
</code>html template for displaying a complete book</p>

<div ng-controller="BookController">
    <div ng-style="{ backgroundImage: 'url(' + getBookImageUrl(100, 100) + ')' }"></div>
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
    <br/>
    Is Available: <span ng-bind="isAvailable() ? 'Yes' : 'No' "></span>
    <br/>
    <button ng-click="deleteBook()">Delete</button>
    <br/>
    <button ng-click="updateBook()">Update</button>
</div>


<p>```</p>

<h2>Sharing a model between controllers</h2>

<p>As long as the book's structure and methods are relevant only to one controller, all is fine and our work here is done. But as the application grows, there might be other controllers that will deal with books. Those controllers will sometimes need to fetch a book, update it, delete it or get it's image url or availability. Therefore we have to share the behaviors of a book between controllers. In order to do this we will use a factory that returns the book's behavior. Before writing this factory, I would like to mention here that we could make the factory return an object that contains helper methods for book (i.e. functions that get a book JSON and do what asked), but I prefer to use <a>prototype</a> for constructing a Book class, which I believe is the right choice:
```javascript Book model service
app.factory('Book', ['$http', function($http) {</p>

<pre><code>function Book(bookData) {
    if (bookData) {
        this.setData(bookData):
    }
    // Some other initializations related to book
};
Book.prototype = {
    setData: function(bookData) {
        angular.extend(this, bookData);
    },
    load: function(id) {
        var scope = this;
        $http.get('ourserver/books/' + bookId).success(function(bookData) {
            scope.setData(bookData);
        });
    },
    delete: function() {
        $http.delete('ourserver/books/' + bookId);
    },
    update: function() {
        $http.put('ourserver/books/' + bookId, this);
    },
    getImageUrl: function(width, height) {
        return 'our/image/service/' + this.book.id + '/' + width + '/' + height;
    },
    isAvailable: function() {
        if (!this.book.stores || this.book.stores.length === 0) {
            return false;
        }
        return this.book.stores.some(function(store) {
            return store.quantity &gt; 0;
        });
    }
};
return Book;
</code></pre>

<p>}]);
<code>
This way all book's behavior is encapsulated in Book service. Now, let's use our shiny Book service in our BookController:
</code>javascript BookController that uses Book model
app.controller('BookController', ['$scope', 'Book', function($scope, Book) {</p>

<pre><code>$scope.book = new Book();
$scope.book.load(1);
</code></pre>

<p>}]);
<code>
As you can see, the controller became very thin. It now creates a Book instance, assigns it to the scope and loads it from the backend. When the book will be loaded, it's properties will be changed and so the template. Keep in mind that other controllers that interact with a book, simply inject the Book service. We have to change the template to use book's methods as well:
</code>html template that uses book instance</p>

<div ng-controller="BookController">
    <div ng-style="{ backgroundImage: 'url(' + book.getImageUrl(100, 100) + ')' }"></div>
    Id: <span ng-bind="book.id"></span>
    <br/>
    Name:<input type="text" ng-model="book.name" />
    <br/>
    Author: <input type="text" ng-model="book.author" />
    <br/>
    Is Available: <span ng-bind="book.isAvailable() ? 'Yes' : 'No' "></span>
    <br/>
    <button ng-click="book.delete()">Delete</button>
    <br/>
    <button ng-click="book.update()">Update</button>
</div>


<p>```
Up to here we saw how to model a data, encapsulate all its methods in one class and share this class between controllers without code duplication.</p>

<h2>Model of the same book in several controllers</h2>

<p>So we have a book model definition and several controllers that work with books. After using this modeling architecture you will notice that there is a big problem.
Up to now we supported several controllers that do operations with books. But what will happen if two controllers will deal with the same book? <br/>
Assume that we have a section with a list of names of all our books and another section with an editable view of a book. We have two controllers, one for each section. The first controller loads the books list and the second controller loads a single book. Our user sees the second section, edit the name of the book and then presses on the "update" button. The update process will succeed and the book name will be changed. But in the books list section the user still sees the old name! What happened actually is that there were two different instances of the same book - one for the books list and one for the editable view. When the user edited the book's name, he actually changed the name property of the book instance that was binded to the editable view. Whereas the book instance that was binded to the books list view didn't changed. <br/>
The solution for this problem is to share the same books instances with any controller that needs them. This way both the books list controller and the editable view controller will hold the same book instance and whenever this instance is changed, the changes will be reflected in all the views. Translating words to actions, we have to create a booksManager service (the letter b is not capital because it is an object and not a Class) that will manage books instances pool and will be responsible for returning instances of books. If the required instance doesn't exist in the pool, the service will create it. If the required instance already exists in the pool, the service will only return it. Keep in mind that all the functions that load instances of books will be defined eventually only in our booksManager service since it has to be the only component that provide books instances.
```javascript booksManager service
app.factory('booksManager', ['$http', '$q', 'Book', function($http, $q, Book) {</p>

<pre><code>var booksManager = {
    _pool: {},
    _retrieveInstance: function(bookId, bookData) {
        var instance = this._pool[bookId];

        if (instance) {
            instance.setData(bookData);
        } else {
            instance = new Book(bookData);
            this._pool[bookId] = instance;
        }

        return instance;
    },
    _search: function(bookId) {
        return this._pool[bookId];
    },
    _load: function(bookId, deferred) {
        var scope = this;

        $http.get('ourserver/books/' + bookId)
            .success(function(bookData) {
                var book = scope._retrieveInstance(bookData.id, bookData);
                deferred.resolve(book);
            })
            .error(function() {
                deferred.reject();
            });
    },
    /* Public Methods */
    /* Use this function in order to get a book instance by it's id */
    getBook: function(bookId) {
        var deferred = $q.defer();
        var book = this._search(bookId);
        if (book) {
            deferred.resolve(book);
        } else {
            this._load(bookId, deferred);
        }
        return deferred.promise;
    },
    /* Use this function in order to get instances of all the books */
    loadAllBooks: function() {
        var deferred = $q.defer();
        var scope = this;
        $http.get('ourserver/books)
            .success(function(booksArray) {
                var books = [];
                booksArray.forEach(function(bookData) {
                    var book = scope._retrieveInstance(bookData.id, bookData);
                    books.push(book);
                });

                deferred.resolve(books);
            })
            .error(function() {
                deferred.reject();
            });
        return deferred.promise;
    },
    /*  This function is useful when we got somehow the book data and we wish to store it or update the pool and get a book instance in return */
    setBook: function(bookData) {
        var scope = this;
        var book = this._search(bookData.id);
        if (book) {
            book.setData(bookData);
        } else {
            book = scope._retrieveInstance(bookData);
        }
        return book;
    },

};
return booksManager;
</code></pre>

<p>}]);
<code>
Our Book service is now without the load method:
</code>javascript Book model without the load method
app.factory('Book', ['$http', function($http) {</p>

<pre><code>function Book(bookData) {
    if (bookData) {
        this.setData(bookData):
    }
    // Some other initializations related to book
};
Book.prototype = {
    setData: function(bookData) {
        angular.extend(this, bookData);
    },
    delete: function() {
        $http.delete('ourserver/books/' + bookId);
    },
    update: function() {
        $http.put('ourserver/books/' + bookId, this);
    },
    getImageUrl: function(width, height) {
        return 'our/image/service/' + this.book.id + '/width/height';
    },
    isAvailable: function() {
        if (!this.book.stores || this.book.stores.length === 0) {
            return false;
        }
        return this.book.stores.some(function(store) {
            return store.quantity &gt; 0;
        });
    }
};
return Book;
</code></pre>

<p>}]);
<code>
Our EditableBookController and BooksListController controllers looks like:
</code>javascript EditableBookController and BooksListController that uses booksManager
app</p>

<pre><code>.controller('EditableBookController', ['$scope', 'booksManager', function($scope, booksManager) {
    booksManager.getBook(1).then(function(book) {
        $scope.book = book
    });
}])
.controller('BooksListController', ['$scope', 'booksManager', function($scope, booksManager) {
    booksManager.loadAllBooks().then(function(books) {
        $scope.books = books
    });
}]);
</code></pre>

<p>```
Notice that the templates remain the same as they still use instances. Now the application will hold only one book instance with id equals to 1 and any change on it will be reflected on all views that use it.</p>

<h2>Summary</h2>

<p>On this article I suggested an architecture for modeling data in AngularJS. First, I presented the default model binding of AngularJS, then I showed how to encapsulate the model's methods and operations so we can share it between different controllers, and finally I explained how to manage our models instances so all the changes will be reflected on all the application views.</p>

<p>I hope this article gave you ideas how to implement your data models. If you have any question, don't hesitate to ask!</p>

<p>NaorYe</p>
]]></content>
  </entry>
  
</feed>
